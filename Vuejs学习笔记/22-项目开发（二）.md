# 滚动区域的Bug分析和解决

* Better-Scroll在决定有多少区域可以滚动时，是根据scrollerHeight属性决定
* ![image-20201123190523670](22-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89.assets/image-20201123190523670.png)
  * scrollHeight属性是根据放Better-Scroll的content中的<u>子组件的高度</u>
  * 但是我们的首页中，刚开始在计算scrollerHeight属性时，是没有将图片计算在内的
  * 所以，计算出来的高度是错误的
  * 后来图片加载进来之后有了新的高度，但是scrollerHeight属性并没有进行更新
  * 所以滚动出现了问题。

* 如何解决？
  * 监听每一张图片是否加载完成，只要有一张图片加载完成了，就执行一次refresh()
  * 如何监听图片加载完成了呢？
    * 原生的js监听图片：`img.onload = function() {}`
    * Vue中监听： `@load=‘方法’`
  * 调用scroll的refresh()

* 如何将GoodsListItem.vue中的事件传入到Home.vue中
  * 因为涉及到非父子组件间的通信，所以这里我们选择了**事件总线**
    * `Vue.prototype.$bus = new Vue()`
    * `this.$bus.$emit('事件名称', 参数)`
    * `this.$bus.$on('事件名称', 回调函数(参数))`

![image-20201124091411375](22-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89.assets/image-20201124091411375.png)

![image-20201124091429493](22-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89.assets/image-20201124091429493.png)

![image-20201124091530393](22-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89.assets/image-20201124091530393.png)

* 通过总线调用refresh方法时可能会有一个问题，那就是scroll组件还没有初始化出来，那么调用scroll组件就相当于`null`，所以我们需要在调用它们时`逻辑'与'上scroll对象`。
  ![image-20201124093721086](22-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89.assets/image-20201124093721086.png)

# 需求：刷新频繁的防抖函数处理

> 一次要加载30张图片，那么按上面的代码网页就会刷新30次，可能1s要请求很多次refresh函数，这样对服务器压力很大。此时，我们不妨进行**防抖**，也就是说比如1秒只刷新一次，而不是只要加载了一张图片就进行刷新。

* 对于refresh非常频繁的问题，进行防抖操作。
  * 防抖debounce/节流throttle
  * 防抖函数起作用的过程：
    * 如果我们直接执行refresh，那么refresh函数会被执行30次。
    * 可以将refresh函数传入到debounce函数中。生成一个新的函数
    * 之后在调用非常频繁的时候，就使用新生成的函数。
    * 而新生成的函数，并不会非常频繁的调用，如果下一次执行来的非常快，那么会将上一次取消掉

```JS
debounce(func, delay) { // 防抖动函数
    let timer = null
    return function (...args) { // ...表示可以传多个参数
        if(timer) clearTimeout(timer)

        timer = setTimeout(()=>{
            func.apply(this, args)
        }, delay)
    }
},
```

将其封装到`utils.js`中

![image-20201124103524493](22-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89.assets/image-20201124103524493.png)

![image-20201124103557116](22-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89.assets/image-20201124103557116.png)



# 上拉加载更多的功能

* Scroll.vue中监听滚到底部
* 子(Scroll)传父(Home)，通过`$emit`
* Home.vue中调用`getHomeGoodsFuc(this.currentType)`获取更多数据

![image-20201124123223499](22-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89.assets/image-20201124123223499.png)

![image-20201124123306804](22-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89.assets/image-20201124123306804.png)

![image-20201124123334776](22-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89.assets/image-20201124123334776.png)

# TabControl的吸顶效果

* 必须知道滚动到多少时，开始有吸附效果

## 获取到tabControl的offsetTop

* 必须知道滚动到多少时，开始有吸附效果，，这个时候就需要获取tabControl的offsetTop
* 但是，如果直接在mounted中获取tabControl的offsetTop，那么值是不正确的。
* 如何获取正确的值呢？
  * 监听HomeSwiper中img的加载完成
  * 加载完成后，发出事件，在Home.vue中获取正确的值。
  * 补充：
    * 为了不让HomeSwiper多次发出事件，
    * 可以使用isLoad的变量进行状态的记录。
  * 注意：这里不进行多次调用和debounce的区别

## 监听滚动，动态改变tabControl的样式

* 问题：动态改变tabControl的样式时，会出现两个问题：
  * 问题一：下面的商品内容，会突然上移
  * 问题二：tabControl虽然设置了fixed，但是也随着Better-Scroll一起滚出去了。
* 其它方案来解决停留问题：
  * 在最上面，多复制一份PlaceHolder TabControl组件对象，利用它来实现停留效果。
  * 当用户滚动到一定位置时，PlaceHolder TabControl显示出来。
  * 当用户滚动没有达到一定位置，PlaceHolder TabControl隐藏起来。

# 让Home保持原来状态

> 切换tab然后返回首页时，避免页面从头开始展示，而是继续展示切换前的页面位置

## 让Home不要随意销毁掉

* keep-alive

## 让Home中的内容保持原来的位置

* 离开时，保存一个位置信息`saveY`
* 进来时，将位置设置为原来保存的位置信息`saveY`即可。
  * 注意，最好回来时，进行一次`refresh()`

# 跳转到详情页并且携带id

通过数据的iid作为query路径

![image-20201124143905991](22-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89.assets/image-20201124143905991.png)

# 详情页

## 数据请求以及轮播图展示



## 商品详细信息的展示



## 店铺信息的解析和展示



## 加入滚动的效果Scroll



## 商品详情数据展示



## 商品参数信息的展示



## 商品推荐数据的展示

用GoodsList组件即可



## 首页和详情页监听全局事件和mixin的使用