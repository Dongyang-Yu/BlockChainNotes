> 本文为中本聪原始论文：《比特币：一种点对点的电子现金系统》，本文介绍了一种共识机制PoW (Proof of  Work)，即工作量证明，俗称“挖矿”。
>
> PoW是指系统为达到某一目标而设置的度量方法。简单理解就是一份证明，用来确认你做过一定量的工作。
>
> * 监测工作的整个**过程**通常是极为低效的
> * 而通过对工作的**结果**进行认证来证明完成了相应的工作量，则是一种非常高效的方式。

# 文章结构

* [介绍](#介绍)
* [交易](##交易)
* [时间戳服务器](##时间戳服务器)
* [工作量证明](##工作量证明)
* [网络](##网络)
* [激励](##激励)
* [回收硬盘空间](##回收硬盘空间)
* [简化支付认证](##简化支付认证)
* [价值的组合与分割](##价值的组合与分割)
* [隐私](##隐私)
* [计算](##计算)
* [结论](#结论)



# 文章内容

## 摘要

一个纯粹的点对点版本的电子现金系统，将允许在线支付直接从一方发送到另一方，而无需通过金融机构。数字签名虽然提供了部分解决方案，但，若是仍然需要被信任的第三方来防止双重支出的话，那么电子支付的主要优势就被抵消了。我们提出一个方案，使用<u>点对点网络</u>（peer-to-peer）去解决双重支出问题。点对点网络将为每笔交易标记时间戳，方法是：把交易的散列数据录入一个不断延展的、以散列为基础的工作证明链上，形成一个如非完全重做就不可能改变的记录。最长链，一方面用来证明已被见证的事件及其顺序，与此同时，也用来证明它来自于最大的 CPU 算力池。只要绝大多数 CPU 算力被良性节点控制 —— 即，它们不与那些尝试攻击网络的节点合作 —— 那么，良性节点将会生成最长链，并且在速度上超过攻击者。这个网络本身需要最小化的结构。信息将以最大努力为基本去传播，节点来去自由；但，加入之时<u>总是需要接受最长的工作证明链作为它们未参与期间所发生之一切的证明</u>。

## 介绍

互联网商业几乎完全依赖金融机构作为可信第三方去处理电子支付。虽然针对大多数交易来说，这个系统还算不错，但，它仍然被基于信任的模型所固有的缺陷所拖累。完全不可逆转的交易实际上并不可能，因为金融机构不能避免仲裁争议。仲裁成本增加了交易成本，进而限制了最小可能交易的规模，且干脆阻止了很多小额支付交易。除此之外，还有更大的成本：系统无法为那些不可逆的服务提供不可逆的支付。**逆转的可能性**，造成了对于信任的需求无所不在。商家必须提防着他们的顾客，麻烦顾客提供更多的信息。一定比例的欺诈，被认为是不可避免的。这些成本和支付不确定性，虽然在人与人之间直接使用物理货币支付的时候是可以避免的；但，没有任何一个机制能在双方在其中一方不被信任的情况下通过沟通渠道进行支付。

我们真正需要的是一种<u>基于加密证明</u>而非基于信任的电子支付系统，允许任意双方在不需要信任第三方的情况下直接交易。算力保障的不可逆转交易能帮助卖家不被欺诈，而保护买家的日常担保机制也很容易实现。在本论文中，我们将提出一种针对双重支出的解决方案，使用点对点的、分布式的时间戳服务器去生成基于算力的证明，按照时间顺序记录每条交易。此系统是安全的，只要诚实节点总体上相对于相互合作的攻击者掌握更多的 CPU 算力。

## 交易

我们定义一枚电子币(electronic coin)作为一个数字签名链(as a chain of digital signatures)。

每一个拥有者(owner)交易货币(coin)给下一个人通过数字签署(私钥签署) <u>上一个交易</u>和<u>下一个人的公钥的hash</u> 并且把这个签署的结果附加在了这个货币的末尾。一个收款人可以验证这个签名来确保这个链的所有权(chain of ownership)，也就是说通过公私钥的方式证明coin的来源与去处。

> 假设A要给B一个coin，那么这个过程就成为一笔交易（比如下方图中间的交易），这个交易会记录给B的coin数量和B的公钥（指明目的地），同时提供A可以操作上一个交易（如下图中最左边的交易，比如这笔交易记录的是X给了A一笔钱，那么就相对于A可以操作X给A的这笔交易的输出），对这两个共同哈希后，付款者A用自己的**私钥**签署这个哈希，然后加在交易的上面。
>
> 之后这笔交易被广泛地广播到其他地方。
>
> 此时作为一个旁观者（矿工），是在自己**本地**具有下图中**第一笔**交易之前的所有交易的，所以看到这个交易（中间的交易）时，就可以用付款者A的公钥（指代的是图中第一笔交易，A的公钥是从第一个交易中获得的）去验证这个交易（中间）的签名从而证实这笔交易是不是由付款者A本人发出的（因为私钥只有A持有），只有用A的私钥进行签署的签名才能和上一笔交易（第一笔交易）进行验证通过，证明A可以操作第一笔交易。
>
> 这样就能证明这笔交易是由付款人A发起的。
>
> 我们以中间的交易作为参照物，这笔交易是有`所有者1`发起的，从图中可以看出，哈希的输入是上一笔交易和下一笔接受者的公钥，哈希的结果（摘要）被`所有者1`的私钥进行签署/加密（生成一个密码），并附在当前的交易上。
>
> 目前不要和下一笔交易连起来看，当`所有者1`签署完这笔交易后，他会把这笔**交易信息**、`所有者1`的**公钥**以及通过私钥加密的**密文**广播出去。
>
> 收到消息的人首先对交易信息进行哈希生成`摘要1`，再通过刚才附带的公钥对密文进行解密，生成摘要2。这样，如果两个摘要相同，说明这个消息确实是A发出的。
>
> ![image-20201203085643654](Bitcoin%20A%20Peer-to-Peer%20Electronic%20Cash%20System.assets/image-20201203085643654.png)
>
> 一旦有结点（矿工）将这笔交易打包进入区块并链在诚实链（最长的链）上时，则这笔交易是成立的。
>
> 所以可以看出此时`所有者2`是不会像正常交易那样立即知道有没有成功的，而是需要过段时间去"查看"（这里是很朴素的说法，也可表示有个东西去轮询，只要交易被打包了就通知`所有者2`）这笔交易有没有被打包，是的话就代表交易成功了。

![image-20201201130539192](Bitcoin%20A%20Peer-to-Peer%20Electronic%20Cash%20System.assets/image-20201201130539192.png)

![image-20201203145434211](Bitcoin%20A%20Peer-to-Peer%20Electronic%20Cash%20System.assets/image-20201203145434211.png)

这个过程的问题在于收款人无法验证曾经的所有者之中没有人[双重支付](##双重支付)过。

常见的解决方案是引入一个可信的中心化权威方，或称“铸币厂”，让它去检查每一笔交易是否存在双重支付。每一次发生交易之后，硬币必须返回到铸币厂，铸币厂再发行一枚新的硬币。进而，只有铸币厂直接发行的硬币才是可信的、未被双重支付过的。这个解决方案的问题在于，整个货币系统的命运被拴在运营铸币厂的那个公司（就好像银行那样）身上，每一笔交易必须通过它。

我们需要一种方式，可以让收款人确认之前的所有者并没有在任何之前的交易上签名。就我们的目的而言，<u>只有最早的交易是算数的</u>，所以，我们并不关心其后的双重支付企图。确认一笔交易不存在的唯一方法是获悉**所有**的交易。在铸币厂模型之中，铸币厂已然知悉所有的交易，并且能够确认这些交易的顺序。为了能在没有“被信任的一方”参与的情况下完成以上任务，交易记录必须被**公开宣布**，进而我们需要一个系统能让参与者们认同它们所接收到的是同一个唯一的交易历史。收款人需要证明在每笔交易发生之时，大多数节点能够认同它是第一个被接收的。

## 时间戳服务器

![image-20201201131430847](Bitcoin%20A%20Peer-to-Peer%20Electronic%20Cash%20System.assets/image-20201201131430847.png)

本解决方案起步于一种时间戳服务器。时间戳服务器是这样工作的：为一组（block）记录（items）的哈希打上时间戳，而后把哈希广播出去，就好像一份报纸所做的那样，或者像是在新闻组（Usenet）里的一个帖子那样。显然，时间戳能够证明那数据在那个时间点之前已然存在，否则那哈希也就无法生成。每个时间戳在其哈希中包含着之前的时间戳，因此构成了一个链；每一个新的时间戳被添加到之前的时间戳之后。

## 工作量证明

> PoW(Proof of Work)，俗称挖矿。

为了实现一个基于点对点的分布式时间戳服务器，我们需要使用类似亚当·伯克的哈希现金那样的一个工作证明系统，而不是报纸或者新闻组帖子那样的东西。

>  The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, the hash begins with a number of zero bits. The average work required is exponential in the number of zero bits required and can be verified by executing a single hash.

所谓的工作证明，就是去寻找一个数值；这个数值要满足以下条件：为它提取散列数值之后 —— 例如使用 SHA-256 计算散列数值 —— 这个散列数值必须以<u>一定数量的 0 开头</u>。每增加一个 0 的要求，将使得工作量指数级增加，并且，这个工作量的验证却只需通过计算一个哈希。

> 在前面提到过A与B首先发生了一笔交易，然后这笔交易被广播，由于没有第三方，因此参与的人就是网络中所有的节点。这些节点在收到该交易和其他好多交易后，打包成为一个区块并加盖上hash。那么现在的问题就来了，如果这些旁观的矿工都**分别**收到了很多交易消息并打包出了自己的区块，那么怎么保证全网达成共识呢？也就是假设C，D，E三个矿工都收到交易消息了，然后因为他们收到的交易消息不完全一致，收到的时间也不完全一致，那么产生的区块的hash肯定天差万别，有p2p经验的人都知道此时就需要保证C，D，E三个人最后需要达成共识，这样才能保证整个网络都认同同一个区块链所发生的“<u>历史事件的顺序</u>”，否则整个体系将会毫无用处。
> 而作者在这里的方式就是引入了PoW来让C，D，E三个人用付出”<u>CPU算力</u>“的途径去以概率性成功的方法去**抢夺**记录区块的权利(也就是俗称的**”记账权“**)。原文中的scan就是指暴力枚举。因为对于SHA-256来说，以目前的密码学来说，要达到某个符合的条件，只有进行暴力枚举的方式去获得。显然，”暴力“的快慢，是由CPU的计算能力决定的，而要暴力的规模，就是这个PoW机制的”难度“。因为要枚举出这个值是以”概率性“的事件，但是因为要经过相当多次枚举，最后平均下来，得到的结果确实可衡量的(也就是概率的**期望值**)。

在我们的时间戳网络中，我们是这样实现工作证明的：不断在区块之中增加一个**随机数**（Nonce），直到一个满足条件的数值被找到；这个条件就是，这个区块的哈希以指定数量的 0 开头。一旦 CPU 的耗费算力所获的的结果满足工作证明，那么这个区块将不再能被更改，除非重新完成之前的所有工作量。随着新的区块不断被添加进来，改变当前区块即意味着说要重新完成所有其后区块的工作。

![image-20201201132549696](Bitcoin%20A%20Peer-to-Peer%20Electronic%20Cash%20System.assets/image-20201201132549696.png)

工作证明同时解决了如何决定谁能代表大多数做决定的问题。如果所谓的“大多数”是基于“一个IP地址一票”（one-IP-one-vote）的方式决定的话，那么任何一个可以搞定很多 IP 地址的人就可以被认为是“大多数”。**工作证明本质上来看，是“一个CPU一票”**（one-CPU-one-vote）。所谓的<u>“大多数决定”是由最长链所代表的</u>，因为被投入最多工作的链就是它。如果大多数 CPU 算力被诚实的节点所控制，那么诚实链成长最为迅速，其速度会远超其他竞争链。

为了更改一个已经产生的区块，攻击者将不得不重新完成那个区块以及所有其后区块的的工作证明，而后还要追上并超过诚实节点的工作。后文展示为什么一个被拖延了的攻击者能够追上的可能性将随着区块的不断增加而指数级降低。

> 这段补充说到PoW实际上就是<u>共同决策选择代表</u>的问题，等价于抢夺记账权问题，因为抢到了记账权，就是选出了代表。这里附加上说到为什么中本聪没有考虑使用IP作为决策的原因，是因为他认为IP作为投票权比CPU作为投票权容易的多(是否是最好的选择不知道，但是目前看来是最好的，不过现在的CPU投票权都被”矿池“所把控，一定程度上产生了动摇性(但仍然比控制IP好的多)，当然也有一些矿池公开宣布自己的算力不超过一个值以维持整个体系的稳定)。随后文章再次强调，想要更改区块，那么攻击者将要付出极大的代价，而诚实的链因为是规则所倡导的，会在博弈中自然的变为最长的链(后文将会描述)。
> 这与PBFT中，通信决策的做法大同小异。

为了应对硬件算力综合的不断增加，以及随着时间推进可能产生的节点参与的数量变化，**工作证明难度**由此决定：基于平均每小时产生的区块数量的<u>一个移动平均值</u>。如果区块生成得过快，那么难度将会增加。

> 这里指出这PoW的难度是随整个系统的难度而一起提升的，因为计算机计算的硬件能力是不断提升的，想想现在的CPU挖矿->显卡挖矿->矿机挖矿，这就是PoW的精妙之处。但是这同样也带来了一个对bitcoin不看好的一个理由：现在的计算机算力因为参与的人太多，而难度提升的很大，整体的算力也水涨船高，近年更是呈指数增长。那么要是过了若干年后，bitcoin的激励(后文提到)所产生的效果不能承受这么高算力的代价，是否会造成算力的断崖式下跌？随之带来的是bitcoin信用的崩溃(能够被掌控算力的人攻击)而导致bitcoin最后突然崩盘？

## 网络

运行网络的步骤如下：

1. 所有新的交易向所有节点广播。
2. 每个节点将新的交易打包到一个区块。
3. 每个节点开始为此区块寻找一个具备难度的工作证明（“挖矿”）。
4. 当某个节点找到其工作证明，它就要将此区块广播给所有的节点。
5. 众多其它节点当且仅当以下条件满足时才会接受这个区块：
   * 其中所有交易都是有效的
   * 且没有被双重支付
6. 众多节点向网络表示自己接受这个区块的方法是，在创建下一个区块的时候，把被接受区块的哈希当作新区块之前的哈希。

节点始终认为**最长链**是正确的那个，且会不断向其添加新数据。若是有两个节点同时向网络广播了两个不同版本的“下一个区块”，有些节点会先接收到其中一个，而另外一些节点会先接收到另外一个。这种情况下，节点将在它们先接收到的那个区块上继续工作，但也会把另外一个分支保存下来，以防后者成为最长链。当下一个工作证明被找到，而其中的一个分支成为更长的链之后，这个暂时的分歧会被打消，<u>在另外一个分支上工作的节点们会切换到更长的链上。</u>

新的交易不见得一定要广播到达所有的节点。只要到达足够多的节点，那么没多久这些交易就会被打包进一个区块。区块广播也容许一些消息被丢弃。如果一个节点并未接收到某个区块，那么这个节点会在它接收到下一个区块的时候意识到自己错失了之前的区块，因此会发出补充那个遗失区块的请求。

## 激励

> 激励机制（Incentive）

按照约定，每个区块的第一笔交易是一个特殊的交易，它会生成一枚新的硬币，所属权是这个区块的生成者。这么做，使得节点支持网络有所奖励，也提供了一种将硬币发行到流通之中的方式 —— 在这个系统中，反正也没有一个中心化的权威方去发行那些硬币。如此这般稳定地增加一定数量的新硬币进入流通，就好像是黄金开采者不断耗用他们的资源往流通之中增加黄金一样。在我们的系统中，被耗用的资源是 <u>CPU 工作时间和它们所用的电力</u>。

奖励还可以来自交易费用（transaction fees）。如果一笔交易的输出值小于它的输入值，那么其中的差额就是交易费；而该交易费就是用来<u>奖励节点把该交易打包进此区块的</u>。一旦既定数量的硬币已经进入流通，那么<u>奖励将全面交由交易手续费</u>来完成，且绝对不会有通货膨胀。

奖励机制也可能会鼓励节点保持诚实。如果一个贪婪的攻击者能够网罗比所有诚实节点都更多的 CPU 算力，他必须做出一个选择：是用这些算力通过把自己花出去的钱偷回来去欺骗别人呢？还是用这些算力去生成新的硬币？他应该能够发现按照规则行事是更划算的，当前规则使得他能够获得比所有其他人加起来都更多的硬币，这显然比暗中摧毁系统并使自己的财富化为虚无更划算。

> 作者太有智慧了 ，通过博弈关系使得攻击者大大减少，更有可能，说服他们成为旷工。

## 回收硬盘空间

> Reclaiming Disk Space

如果最近的交易已经被纳入了<u>足够多</u>的区块之中，那么就可以丢弃该交易之前的数据——目的是为了节省磁盘空间。为了确保不损害该区块的哈希的前提下实现该功能，交易记录的哈希将被纳入一个Merkle树（Merkle tree）之中，使得只有根(root)被纳入该区块的哈希之中。通过砍掉树枝（stubbing）的方法，老区块就能被压缩。而内部的哈希并不需要保存。

> 这段是针对区块链系统会不断产生的区块问题的一个解决方案。如截止2017年初，区块链总数已经超过了90G，虽然存储是越来越不值钱了，但是要普通公众使用是不可能的，因为信息在一直膨胀。这里就体现出区块链系统的精妙之处，它<u>不存储交易</u>，而是使用Merkel Hash Tree的方式存储Root Hash，达到”0知识证明“。个人并不一定需要这个区块，而是具有这个区块的”hash“(**索引**)就足够了，有IPFS，公共节点，信任度高节点帮助存储这些区块。”0知识证明“保证了区块是绝对正确的而不是伪造的。

![image-20201201143156005](Bitcoin%20A%20Peer-to-Peer%20Electronic%20Cash%20System.assets/image-20201201143156005.png)

一个没有任何交易记录的区块头大约是 80 个字节。假设每十分钟产生一个区块，80 字节乘以 6 乘以 24 乘以 365，等于每年 4.2M。截止 2008 年，大多数在售的计算机配有 2GB 内存，而按照摩尔定律的预测，每年会增加 1.2 GB，即便是区块头必须存储在内存之中也不会是什么问题。

## 简化支付认证

> Simplified Payment Verification

即便不用运行一个完整网络节点也有可能确认支付。用户只需要有一份拥有工作证明的<u>最长链的区块头</u>拷贝 —— 他可以通过查询在线节点确认自己拥有的确实来自最长链 —— 而后获取 Merkle 树的树枝节点，进而连接到这个区块被打上时间戳时的交易。用户并不能自己检查交易，但，通过连接到链上的某个地方，他可以看到某个网络节点已经接受了这个交易，而此后加进来的区块进一步确认了网络已经接受了此笔交易。

> 而回收硬盘空间所带来的问题就是简化支付认证的问题，因为有些节点已经不会持有全部区块信息，这里相当于是一个博弈了，使用空间换认证的便捷。但总之是不会在信息的安全性上出问题的。因为只要持有了hash作为标识，无论什么节点总是能从其他节点上请求到原始信息。

![image-20201201143858501](Bitcoin%20A%20Peer-to-Peer%20Electronic%20Cash%20System.assets/image-20201201143858501.png)

只要诚实节点依然在掌控网络，如此这般，验证即为可靠的。然而，如果网络被攻击者所控制的时候，验证就没那么可靠了。尽管网络节点可以自己验证交易记录，但是，只要攻击者能够继续控制网络的话，那么简化版验证方式可能会被攻击者伪造的交易记录所欺骗。

应对策略之一是，客户端软件要接受来自网络节点的警告。当网络节点发现无效区块的时候，即发出警报，在用户的软件上弹出通知，告知用户下载完整区块，警告用户确认交易一致性。那些有高频收付发生的商家应该仍然希望运行属于自己的完整节点，以此保证更独立的安全性和更快的交易确认。

## 价值的组合与分割

> Combining and Splitting Value

尽管逐个地处理硬币是可能的，但为每分钱设置一个单独的记录是很笨拙的。为了允许价值的分割与合并，交易记录包含<u>多个输入和输出</u>。

一般而言是某次价值较大的之前的交易构成的单一输入，或者由某几个价值较小的前次交易共同构成的并行输入，但是输出最多只有两个：

* 一个用于支付（指向收款方），
* 另一个用于找零（如有）（指向发款方）。 

![image-20201201145022725](Bitcoin%20A%20Peer-to-Peer%20Electronic%20Cash%20System.assets/image-20201201145022725.png)

值得注意的是，“**扇出**”（fan-out）在这里并不是问题 —— 所谓“扇出”，就是指一笔交易依赖于数笔交易，且这些交易又依赖于更多笔交易。从来就没有必要去提取任何一笔交易的完整独立的历史拷贝。

## 隐私

> Privacy

传统的银行模型通过限制他人获取交易者和可信第三方的信息而达成一定程度的隐私保护。出于对将所有交易记录公开的需求否决了这种方法。但是，维持隐私可通过于另一处的切断信息流来实现——**公钥匿名**(public keys anonymous)。公众可以看到某某向某某转账了一定的金额，但是，没有任何信息指向某个确定的人。这种水平的信息发布有点像股市交易，只有时间和各个交易的金额被公布，但是，没有人知道交易双方都是谁。

这里指出使用公私钥的机制是一种伪匿名化。

![image-20201201145833353](Bitcoin%20A%20Peer-to-Peer%20Electronic%20Cash%20System.assets/image-20201201145833353.png)

还有另外一层防火墙。交易者应该针对每一笔交易<u>启用一对新的公私钥</u>，以便他人无法将这些交易追溯到同一个所有者身上。有些多输入的交易依然难免被追溯，因为那些输入必然会被识别出来自于同一个所有者。危险在于，如果一个公钥的所有者被曝光之后，与之相关的所有其他交易都会被曝光。

## 计算

> Calculations

假设一个场景，某个攻击者正在试图生成一个比诚实链更快的替代链。就算他成功了，也不会使当前系统置于模棱两可的尴尬境地，即，他不可能凭空制造出价值，也无法获取从未属于他的钱。网络节点不会把一笔无效交易当作支付，而诚实节点也永远不会接受一个包含这种支付的区块。攻击者最多只能修改属于他自己的交易，进而试图取回他已经花出去的钱。

诚实链和攻击者之间的竞争可以用二项式随机漫步（Binomial Random Walk）来描述。成功事件是诚实链刚刚被添加了一个新的区块，使得它的优势增加了1 ；而失败事件是攻击者的链刚刚被增加了一个新的区块，使得诚实链的优势减少了1 。

攻击者能够从落后局面追平的概率类似于**赌徒破产**（Gambler's Ruin problem）问题。假设，一个拿着无限筹码的赌徒，从亏空开始，允许他赌无限次，目标是填补上已有的亏空。我们能算出他最终能填补亏空的概率，也就是攻击者能够赶上诚实链的概率，如下：

论文中展示了攻击者追赶上诚实链的概率问题。

[计算部分详解](https://zhuanlan.zhihu.com/p/56151888)

## 结论

我们提出了一个不必依赖信任的电子交易系统；

起点是一个普通的使用数字签名的硬币框架开始，虽然它提供了健壮的所有权控制，却无法避免双重支付。

为了解决这个问题，我们提出一个使用工作证明机制的点对点网络去记录一个公开的交易记录历史，<u>只要诚实节点能够控制大多数 CPU 算力，那么攻击者就仅从算力方面就不可能成功篡改系统</u>。这个网络的健壮在于它的非结构化的简洁性。节点们只需很少协同就能同时工作。它们甚至不需要被辨认，因为消息的路径并非取决于特定的终点；消息只需要被以最大努力为基本去传播即可。

节点来去自由，重新加入时，只需要接受工作证明链，作为它们离线之时所发生之一切的证明。

它们通过它们的 CPU 算力投票，通过不断为链添加新的有效区块、拒绝无效区块，去表示它们对有效交易的接受与否。任何必要的规则和奖励都可以通过这个共识机制来强制实施。

# 相关资料

## 双重支付

> Double-spending，又称为双花支付。是指同一笔钱花了两次甚至是多次。

不同于实物货币，由于比特币是数字货币，本身就是一些代码，所以具有**可复制性**，而且由于比特币网络的开放性，任何人都可以将交易自由地广播到比特币网络上，所以不诚实的节点就可能会做出双花支付。

假设在比特币网络中，一个不诚实节点发起了双花交易。但是根据区块链的共识机制，网络节点只接受收到的第一个交易，所以第二个交易将被拒绝。不过，由于区块链网络是多点连接，所以有可能出现这种情况，一些节点接受了第一笔交易，另外一些节点接受了第二笔交易



# 启发

中本聪提出的方法，是把基于信用的模式改为基于密码学。

另外，就安全性来说，作者通过引入工作量证明来防止恶意攻击。在比特币中，因为每一笔交易都需要经过计算机运算加密，所以账本上的这些交易，都是需要消耗时间才能注记上去的。要完成一份假的比特币工作量证明，则必须先控制整个网络上过半的计算机，让它们都认证假的交易纪录，才有可能达成。但是既然能控制过半的计算机，为什么还要去攻击呢？这不是多此一举吗？所以，从人性的角度也能防止恶意攻击。





# 参考

论文解读：https://zhuanlan.zhihu.com/p/25039679

https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system

论文翻译：http://www.btcpapers.com/