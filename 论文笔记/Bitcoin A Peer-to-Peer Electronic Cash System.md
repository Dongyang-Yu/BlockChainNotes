> 本文为中本聪原始论文：《比特币：一种点对点的电子现金系统》，本文介绍了一种共识机制PoW (Proof of  Work)，即工作量证明，俗称“挖矿”。
>
> PoW是指系统为达到某一目标而设置的度量方法。简单理解就是一份证明，用来确认你做过一定量的工作。
>
> * 监测工作的整个**过程**通常是极为低效的
> * 而通过对工作的**结果**进行认证来证明完成了相应的工作量，则是一种非常高效的方式。

# 文章结构

* 简介
* [交易](##交易)
* [时间戳服务器](##时间戳服务器)
* [工作量证明](##工作量证明)
* [网络](##网络)
* [激励](##激励)
* 回收硬盘空间
* [简化支付认证](##简化支付认证)
* [价值的组合与分割](##价值的组合与分割)
* [隐私](##隐私)
* [计算](##计算)
* [结论](#结论)



# 文章内容

## 交易

我们定义，一枚电子货币(an electronic coin)是数字签名链。币的转移是通过：

* 每一位**所有者**对前一笔交易和下一位所有者的公钥(Public key) 分别签署一个**随机散列的数字签名**，并将这两个签名附加在这枚电子货币的末端。
* 而**收款人**通过对签名检验，来验证该链的所有权。

![image-20201112154230135](Bitcoin%20A%20Peer-to-Peer%20Electronic%20Cash%20System.assets/image-20201112154230135.png)

问题是收款人无法验证其中一个所有者没有进行[双花](##双重支付)。一个常见的解决办法是引入一个可信中央权威机构（或造币厂），检查交易是否被双花。每次交易后，必须将币退还给造币厂以发行新的币，只有从造币厂发行的币可以确信没有双花。这个解决方案的问题是，整个货币体系的命运<u>取决于运营造币厂的公司</u>，每一笔交易都要经过它们，就像银行一样。

我们需要一种方法让收款人知道之前的拥有者没有将币用于早些的交易。就这个目的而言，<u>最初的交易是最关键的</u>，所以我们不关心之后是否进行了双花。确认交易是否存在的唯一方法是了解**所有**交易。在造币厂模型中，造币厂了解所有的交易，并决定哪一笔交易是第一个。为了在没有信任方的情况下达到这个目的，交易必须被**公开宣布**，我们需要一个系统，让参与者基于他们接收到的事实就序列的单一历史达成共识。收款人需要证据，来表明在每次交易时，大多数节点都同意这笔交易是第一次收到的（从而防止双发）。

## 时间戳服务器

![image-20201112162015677](Bitcoin%20A%20Peer-to-Peer%20Electronic%20Cash%20System.assets/image-20201112162015677.png)

作者提出的解决方案是从一个时间戳服务器开始的。时间戳服务器通过对以区块(block)形式存在的一组数据进行哈希来得到时间戳，并广泛发布该哈希值，如在报纸或Usenet帖子中。显然，该时间戳能够证特定数据在某特定时间里是必然存在的，因为只有在该时刻存在了才能去获取相应的随机散列值。

每个时间戳的哈希值中都包含**之前**的时间戳，每个新加的时间戳都对它之前的时间戳进行了增强，这样就形成了一个链条(chain)。

## 工作量证明

> PoW(Proof of Work)

为了实现一个基于p2p的分布式时间戳服务器，当哈希一个值时，工作量证明机制引入了对该值的扫描(scan)，例如在SHA-256下，这个hash从一串0bits开始。需要的平均工作就是所需0bit数的指数，并且可以通过执行单个hash来被验证。

> 在前面提到过A与B首先发生了一笔交易，然后这笔交易被广播，由于没有第三方，因此参与的人就是网络中所有的节点。这些节点在收到该交易和其他好多交易后，打包成为一个区块并加盖上hash。那么现在的问题就来了，如果这些旁观的矿工都**分别**收到了很多交易消息并打包出了自己的区块，那么怎么保证全网达成共识呢？也就是假设C，D，E三个矿工都收到交易消息了，然后因为他们收到的交易消息不完全一致，收到的时间也不完全一致，那么产生的区块的hash肯定天差万别，有p2p经验的人都知道此时就需要保证C，D，E三个人最后需要达成共识，这样才能保证整个网络都认同同一个区块链所发生的“<u>历史事件的顺序</u>”，否则整个体系将会毫无用处。
> 而作者在这里的方式就是引入了PoW来让C，D，E三个人用付出”<u>CPU算力</u>“的途径去以概率性成功的方法去**抢夺**记录区块的权利(也就是俗称的**”记账权“**)。原文中的scan就是指暴力枚举。因为对于SHA-256来说，以目前的密码学来说，要达到某个符合的条件，只有进行暴力枚举的方式去获得。显然，”暴力“的快慢，是由CPU的计算能力决定的，而要暴力的规模，就是这个POW机制的”难度“。因为要枚举出这个值是以”概率性“的事件，但是因为要经过相当多次枚举，最后平均下来，得到的结果确实可衡量的(也就是概率的**期望值**)。

我们在区块中补增一个**随机数**(Nonce)，这个随机数要使得该给定区块的随机散列值(hash)出现了所需的那么多个0。我们通过反复尝试来找到这个随机数，直到找到为止，这样我们就构建了一个工作量证明机制。只要该CPU耗费的工作量能够满足该工作量证明机制，那么除非重新完成相当的工作量，否则该区块的信息就不可更改。由于之后的区块是链接在该区块之后的，所以想要更改该区块中的信息，就还需要重新完成之后所有区块的全部工作量。

工作量证明同时解决了多数决策中决定代表的问题。如果大多数人只根据一人一ip进行投票(one-IP-one-vote)，这样会被任何能够分配很多ip的人破坏。工作量证明<u>本质上是一CPU一票</u>(one-CPU-one-vote)。主要的(大多数)的决定是由最长的链所代表，因为它包含了最大的工作量证明工作。如果一个大多数CPU算力都被诚实节点所控制，那么最诚实的链就会增长的最快且超过其他任何计算链。
想要改变一个过去的区块，攻击者需要重做这个区块和所有在这个块后的区块的工作量证明，之后还要追赶上并超过现在所有诚实节点的工作。之后会展示，随着后续区块被添加，一个慢速的攻击者能够追赶上(catching up)的可能性会指数级的减少。

> 这段补充说到PoW实际上就是<u>共同决策选择代表</u>的问题，等价于抢夺记账权问题，因为抢到了记账权，就是选出了代表。这里附加上说到为什么中本聪没有考虑使用IP作为决策的原因，是因为他认为IP作为投票权比CPU作为投票权容易的多(是否是最好的选择不知道，但是目前看来是最好的，不过现在的CPU投票权都被”矿池“所把控，一定程度上产生了动摇性(但仍然比控制IP好的多)，当然也有一些矿池公开宣布自己的算力不超过一个值以维持整个体系的稳定)。随后文章再次强调，想要更改区块，那么攻击者将要付出极大的代价，而诚实的链因为是规则所倡导的，会在博弈中自然的变为最长的链(后文将会描述)。
> 这与PBFT中，通信决策的做法大同小异。

为了补偿不断增长的硬件速度，和随着时间推移不断变化兴趣的运行节点(varying interest)，**工作量的困难度**是由<u>一个移动的平均目标</u>决定，就是每一个小时的平均区块。如果这些计算力增长的太快，这个困难度就会增加。

> 这里指出这PoW的难度是随整个系统的难度而一起提升的，因为计算机计算的硬件能力是不断提升的，想想现在的CPU挖矿->显卡挖矿->矿机挖矿，这就是PoW的精妙之处。但是这同样也带来了一个对bitcoin不看好的一个理由：现在的计算机算力因为参与的人太多，而难度提升的很大，整体的算力也水涨船高，近年更是呈指数增长。那么要是过了若干年后，bitcoin的激励(后文提到)所产生的效果不能承受这么高算力的代价，是否会造成算力的断崖式下跌？随之带来的是bitcoin信用的崩溃(能够被掌控算力的人攻击)而导致bitcoin最后突然崩盘？

## 网络

运行这个网络的步骤如下：

1. 新的交易被广播到全部的节点。
2. 每一个节点把新的交易收集进入到一个区块。
3. 每一个节点都为自己的那块区块进行工作（“挖矿”）去找到那个工作量证明。
4. 当一个节点找到了这个块的工作量证明，它把这个块广播给所有的节点。
5. 只能当这个区块中的所有的交易都是有效的并且都没有被花费过，节点们才会接受这个块。
6. 节点们通过使用当前区块的hash作为下一个区块的prev hash创建链中下一个区块，来表示对当前区块的认可。

节点们总是只考虑**最长的链**是正确的并且不断为扩展它进行工作。如果2个节点同时广播不同版本的下一个块，一些节点会首先收到其中一个块，在这种情况下，他们为收到第一个块而工作，不过另一块保存下来以防它会变得更长。
当下一个工作量证明被发现并且此时有一条分支变得更长时，这个平衡(tie)将会被打破。在其他分支工作的节点们将会转换到这个最长的分支上。

新交易的广播到所有的节点上是不必要的。只要交易信息能够抵达足够多的节点，它们就会整合进一个区块中。区块广播是有容错丢失信息的能力的。如果一个节点没有收到某个特定块，那么它在收到下一区块时就会发现自己缺失了它并提出自己要下载该区块的请求。

## 激励

> 激励机制（Incentive）

约定如此：每个区块中的第一笔交易是一个特殊交易，该交易产生一枚由该区块创造者拥有的新的电子货币。

这样就增加了节点支持该网络的激励，并在没有中央集权机构发行货币的情况下，提供了一种将电子货币分配到流通领域的一种方法。这种将一定数量新货币持续增添到货币系统中的方法，非常类似于耗费资源去挖掘金矿并将黄金注入到流通领域。此时，<u>CPU的时间和电力消耗</u>就是消耗的资源。

另外一个激励的来源则是交易费（transaction fees）。如果某笔交易的输出值小于输入值，那么差额就是交易费，该交易费将被增加到该区块的激励中。只要既定数量的电子货币已经进入流通，那么激励机制就可以逐渐转换为<u>完全依靠交易费</u>，那么本货币系统就能够免于通货膨胀。 激励系统也有助于鼓励节点保持诚实。

如果有一个贪婪的攻击者能够调集比所有诚实节点加起来还要多的CPU计算力，那么他就面临一个选择：要么将其用于诚实工作产生新的电子货币，或者将其用于进行二次支付攻击。那么他就会发现，按照规则行事、诚实工作是更有利可图的。因为该等规则使得他能够拥有更多的电子货币，而不是破坏这个系统使得其自身财富的有效性受损。

> 作者太有智慧了 ，通过博弈关系使得攻击者大大减少，更有可能，说服他们成为旷工。

## 回首硬盘空间

> Reclaiming Disk Space

如果最近的交易已经被纳入了<u>足够多</u>的区块之中，那么就可以丢弃该交易之前的数据，以回收硬盘空间。为了同时确保不损害区块的随机散列值，交易信息被hash时，被构建成一种Merkle树（Merkle tree）的形态，使得只有根(root)被纳入了区块的随机散列值。通过将该树（tree）的分支拔除（stubbing）的方法，老区块就能被压缩。而内部的随机散列值是不必保存的。

> 这段是针对区块链系统会不断产生的区块问题的一个解决方案。如截止2017年初，区块链总数已经超过了90G，虽然存储是越来越不值钱了，但是要普通公众使用是不可能的，因为信息在一直膨胀。这里就体现出区块链系统的精妙之处，它<u>不存储交易</u>，而是使用Merkel Hash Tree的方式存储Root Hash，达到”0知识证明“。个人并不一定需要这个区块，而是具有这个区块的”hash“(**索引**)就足够了，有IPFS，公共节点，信任度高节点帮助存储这些区块。”0知识证明“保证了区块是绝对正确的而不是伪造的。

![image-20201113095309269](Bitcoin%20A%20Peer-to-Peer%20Electronic%20Cash%20System.assets/image-20201113095309269.png)

不含交易信息的区块头（Block header）大小仅有80字节。如果我们设定区块生成的速率为每10分钟一个，那么每一年产生的数据位4.2MB。`（80 bytes * 6 * 24 * 365 = 4.2MB）`。2008年，PC系统通常的内存容量为2GB，按照摩尔定律预言的每年增长1.2GB的大小，即使将全部的区块头存储于内存之中都不是问题。

## 简化支付认证

> Simplified Payment Verification

在不运行完整网络节点的情况下，也能够对支付进行检验。一个用户需要保留最长工作量证明链条的区块<u>头的拷贝</u>，它可以不断向网络发起询问，直到它确信自己拥有最长的链条，并能够通过Merkle的分支通向它被加上时间戳并纳入区块的那次交易。节点想要自行检验该交易的有效性原本是不可能的，但通过追溯到链条的某个位置，它就能看到某个节点曾经接受过它，并且于其后追加的区块也进一步证明全网曾经接受了它。

> 而回收硬盘空间所带来的问题就是简化支付认证的问题，因为有些节点已经不会持有全部区块信息，这里相当于是一个博弈了，使用空间换认证的便捷。但总之是不会在信息的安全性上出问题的。因为只要持有了hash作为标识，无论什么节点总是能从其他节点上请求到原始信息。



![image-20201113101613391](Bitcoin%20A%20Peer-to-Peer%20Electronic%20Cash%20System.assets/image-20201113101613391.png)

这样的情景下，如要诚实节点控制了网络，那么这个验证就是可靠的，但是当一个算力占优的攻击者控制网络的时候就变得更容易受攻击了。因为网络中的节点能够自己进行验证的时候，这个简化的方法能够被攻击者伪造的(fabricated)的交易欺骗，当这个攻击者能够持续保证超过全网的算力的时候。
一种保护的策略是接受网络节点们的警告，当这些网络节点监测到一个非法的区块，提醒用户软件去下载这个有问题的全部区块，并警告交易去检查确认一致性。频繁收到支付信息的商业机构可能会仍然运行他们的全节点以保持更加独立的安全性和更快的验证。

## 价值的组合与分割

> Combining and Splitting Value

虽然可以单个单个地对电子货币进行处理，但是对于每一枚电子货币单独发起一次交易将是一种笨拙的办法。为了使得价值易于组合与分割，交易被设计为可以**容纳多个输入和输出**。
一般而言是某次价值较大的前次交易构成的单一输入，或者由某几个价值较小的前次交易共同构成的并行输入，但是输出最多只有两个：

* 一个用于支付，
* 另一个用于找零（如有）。 

需要指出的是，当一笔交易依赖于之前的多笔交易时，这些交易又各自依赖于多笔交易，但这并不存在任何问题。因为这个工作机制并不需要展开检验之前发生的所有交易历史。

## 隐私

> Privacy

传统的造币厂模型为交易的参与者提供了一定程度的隐私保护，因为试图向可信任的第三方索取交易信息是严格受限的。但是如果将交易信息向全网进行广播，就意味着这样的方法失效了。
但是隐私依然可以得到保护：<u>将公钥保持为匿名</u>。公众得知的信息仅仅是有某个人将一定数量的货币发所给了另外一个人，但是难以将该交易同特定的人联系在一起，也就是说，公众难以确信，这些人究竟是谁。这同股票交易所发布的信息是类似的，股票交易发生的时间、交易量是记录在案且可供查询的，但是交易双方的身份信息却不予透露。 

> 这里指出使用公私钥的机制是一种伪匿名化。

![image-20201113103115415](Bitcoin%20A%20Peer-to-Peer%20Electronic%20Cash%20System.assets/image-20201113103115415.png)

作为额外的预防措施，使用者可以让每次交易都生成一个新的地址，以确保这些交易不被追溯到一个共同的所有者。但是由于并行输入的存在，一定程度上的追溯还是不可避免的，因为并行输入表明这些货币都属于同一个所有者。此时的风险在于，如果某个人的某一个公钥被确认属于他，那么就可以追溯出此人的其它很多交易。

## 计算

> Calculations

我们考虑这样一个场景：一个攻击者尝试去生成一个比现在最诚实链还长的替换链。即便这样是可完成的，这也不会抛出这个系统就被任意控制了，比如像凭空创造价值或者拿去本来不属于攻击者的钱。节点是不会接受无效的交易作为支付的，并且最诚实链从不会接受一个包含无效信息的区块。一个攻击者只可以尝试去改变他自己的一个交易去拿回他最近花掉的钱。

最诚实链和攻击者链的竞争可以看作是一个Binomial Random Walk(二叉树随机漫步)。成功事件是最诚实链扩大了一个区块，使其+1领先(lead)，同时失败事件是攻击者链扩大一个区块，使得-1差距(gap)。

攻击者能够从落后局面追平的概率类似于赌徒破产问题。假设，一个拿着无限筹码的赌徒，从亏空开始，允许他赌无限次，目标是填补上已有的亏空。我们能算出他最终能填补亏空的概率，也就是攻击者能够赶上诚实链的概率。

论文中展示了攻击者追赶上诚实链的概率问题。



# 相关资料

## 双重支付

> Double-spending，又称为双花支付。是指同一笔钱花了两次甚至是多次。

不同于实物货币，由于比特币是数字货币，本身就是一些代码，所以具有可复制性，而且由于比特币网络的开放性，任何人都可以将交易自由地广播到比特币网络上，所以不诚实的节点就可能会做出双花支付，**不过由于区块链本身所提供的共识机制是完全可以阻止这种情况的出现的，但是如果有人控制了比特币网络中的大量算力，那么双花支付就可能成功。**



# 结论

本文提出了一种不需要依赖“信用”的电子支付交易系统。

作者从数字签名构成的通用币框架开始，这种系统虽然提供了对所有权强有力的控制，但由于没有办法防止双重支付，仍然是不完整的。为了解决这个问题，我们提出了一种采用工作量证明机制的点对点网络来记录交易的公开历史，在诚实节点控制多数算力的情况下，攻击者要改变交易会迅速变得不切实际。

该网络的强健之处在于它非结构化的简洁性。所有节点只需要少量沟通就可同时工作。他们不需要被识别，因为信息没有路由到任何特定的地方，只需要以尽力而为的方式交付。节点可以随意离开网络，而想要重新加入网络也只需要接受其离开期间的工作量证明链即可。<u>节点通过自己的CPU算力进行投票，通过扩展/延长有效的区块表达自己的认可、通过拒绝在无效的区块之后延长来表示否定。</u>任何所需的规则和激励都可以通过这个共识机制来实施。



# 启发

中本聪提出的方法，是把基于信用的模式改为基于密码学。

另外，就安全性来说，作者通过引入工作量证明来防止恶意攻击。在比特币中，因为每一笔交易都需要经过计算机运算加密，所以账本上的这些交易，都是需要消耗时间才能注记上去的。要完成一份假的比特币工作量证明，则必须先控制整个网络上过半的计算机，让它们都认证假的交易纪录，才有可能达成。但是既然能控制过半的计算机，为什么还要去攻击呢？这不是多此一举吗？所以，从人性的角度也能防止恶意攻击。





# 参考：

https://zhuanlan.zhihu.com/p/25039679

https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system