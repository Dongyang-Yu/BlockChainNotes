> 本文档目为农产品溯源项目源码解析

# 下载fabric

获取fabric安装的脚本文件，该脚本为1.4版本（第一个LTS版本，现在为2.X）。

```bash
curl -sSL https://raw.githubusercontent.com/hyperledger/fabric/release-1.4/scripts/bootstrap.sh
```

> 上方链接需翻墙才可下载，替代方法为找到该仓库的[源文件](https://github.com/hyperledger/fabric/blob/release-1.4/scripts/bootstrap.sh)新建`.sh`后缀文件将源码粘贴。
>
> 坑点：由于1.4版本源码中所展示的网站`nexus.hyperledger.org`不再维护，`2.0.0`之后的版本都是从GitHub上直接下载了（[参考](https://blog.csdn.net/qq_39800434/article/details/105094313/)）。所以运行脚本`bootstrap.sh`修改为如下：
>
> * 笔者将GitHub地址用国内镜像代替（`github.com.cnpmjs.org`）

```BASH
#!/bin/bash
#
# Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
#

# if version not passed in, default to latest released version
export VERSION=1.4.9
# if ca version not passed in, default to latest released version
export CA_VERSION=1.4.9
# current version of thirdparty images (couchdb, kafka and zookeeper) released
export THIRDPARTY_IMAGE_VERSION=0.4.21
export ARCH=$(echo "$(uname -s|tr '[:upper:]' '[:lower:]'|sed 's/mingw64_nt.*/windows/')-$(uname -m | sed 's/x86_64/amd64/g')")
export MARCH=$(uname -m)

printHelp() {
  echo "Usage: bootstrap.sh [version [ca_version [thirdparty_version]]] [options]"
  echo
  echo "options:"
  echo "-h : this help"
  echo "-d : bypass docker image download"
  echo "-s : bypass fabric-samples repo clone"
  echo "-b : bypass download of platform-specific binaries"
  echo
  echo "e.g. bootstrap.sh 1.4.9 -s"
  echo "would download docker images and binaries for version 1.4.9"
}

dockerFabricPull() {
  local FABRIC_TAG=$1
  for IMAGES in peer orderer ccenv javaenv tools; do
      echo "==> FABRIC IMAGE: $IMAGES"
      echo
      docker pull hyperledger/fabric-$IMAGES:$FABRIC_TAG
      docker tag hyperledger/fabric-$IMAGES:$FABRIC_TAG hyperledger/fabric-$IMAGES
  done
}

dockerThirdPartyImagesPull() {
  local THIRDPARTY_TAG=$1
  for IMAGES in couchdb kafka zookeeper; do
      echo "==> THIRDPARTY DOCKER IMAGE: $IMAGES"
      echo
      docker pull hyperledger/fabric-$IMAGES:$THIRDPARTY_TAG
      docker tag hyperledger/fabric-$IMAGES:$THIRDPARTY_TAG hyperledger/fabric-$IMAGES
  done
}

dockerCaPull() {
      local CA_TAG=$1
      echo "==> FABRIC CA IMAGE"
      echo
      docker pull hyperledger/fabric-ca:$CA_TAG
      docker tag hyperledger/fabric-ca:$CA_TAG hyperledger/fabric-ca
}

samplesInstall() {
  # clone (if needed) hyperledger/fabric-samples and checkout corresponding
  # version to the binaries and docker images to be downloaded
  if [ -d first-network ]; then
    # if we are in the fabric-samples repo, checkout corresponding version
    echo "===> Checking out v${VERSION} of hyperledger/fabric-samples"
    git checkout v${VERSION}
  elif [ -d fabric-samples ]; then
    # if fabric-samples repo already cloned and in current directory,
    # cd fabric-samples and checkout corresponding version
    echo "===> Checking out v${VERSION} of hyperledger/fabric-samples"
    cd fabric-samples && git checkout v${VERSION}
  else
    echo "===> Cloning hyperledger/fabric-samples repo and checkout v${VERSION}"
    git clone -b master https://github.com.cnpmjs.org/hyperledger/fabric-samples.git && cd fabric-samples && git checkout v${VERSION}
  fi
}

# Incrementally downloads the .tar.gz file locally first, only decompressing it
# after the download is complete. This is slower than binaryDownload() but
# allows the download to be resumed.
binaryIncrementalDownload() {
      local BINARY_FILE=$1
      local URL=$2
      curl -f -s -C -L --retry 5 --retry-delay 3 - ${URL} -o ${BINARY_FILE} || rc=$?
      # Due to limitations in the current Nexus repo:
      # curl returns 33 when there's a resume attempt with no more bytes to download
      # curl returns 2 after finishing a resumed download
      # with -f curl returns 22 on a 404
      if [ "$rc" = 22 ]; then
	  # looks like the requested file doesn't actually exist so stop here
	  return 22
      fi
      if [ -z "$rc" ] || [ $rc -eq 33 ] || [ $rc -eq 2 ]; then
          # The checksum validates that RC 33 or 2 are not real failures
          echo "==> File downloaded. Verifying the md5sum..."
              tar xzf ./${BINARY_FILE} --overwrite
      else
          echo "Failure downloading binaries (curl RC=$rc). Please try again and the download will resume from where it stopped."
          exit 1
      fi
}

# This will attempt to download the .tar.gz all at once, but will trigger the
# binaryIncrementalDownload() function upon a failure, allowing for resume
# if there are network failures.
binaryDownload() {
      local BINARY_FILE=$1
      local URL=$2
      echo "===> Downloading: " ${URL}
      # Check if a previous failure occurred and the file was partially downloaded
      if [ -e ${BINARY_FILE} ]; then
          echo "==> Partial binary file found. Resuming download..."
          binaryIncrementalDownload ${BINARY_FILE} ${URL}
      else
          curl -L --retry 5 --retry-delay 3 ${URL} | tar xz || rc=$?
          if [ ! -z "$rc" ]; then
              echo "==> There was an error downloading the binary file. Switching to incremental download."
              echo "==> Downloading file..."
              binaryIncrementalDownload ${BINARY_FILE} ${URL}
	  else
	      echo "==> Done."
          fi
      fi
}

binariesInstall() {
  echo "===> Downloading version ${FABRIC_TAG} platform specific fabric binaries"
  binaryDownload ${BINARY_FILE} https://github.com.cnpmjs.org/hyperledger/fabric/releases/download/v${VERSION}/${BINARY_FILE}
  if [ $? -eq 22 ]; then
     echo
     echo "------> ${FABRIC_TAG} platform specific fabric binary is not available to download <----"
     echo
   fi

  echo "===> Downloading version ${CA_TAG} platform specific fabric-ca-client binary"
  binaryDownload ${CA_BINARY_FILE} https://github.com.cnpmjs.org/hyperledger/fabric-ca/releases/download/v${CA_VERSION}/${CA_BINARY_FILE}
  if [ $? -eq 22 ]; then
     echo
     echo "------> ${CA_TAG} fabric-ca-client binary is not available to download  (Available from 1.1.0-rc1) <----"
     echo
   fi
}

dockerInstall() {
  which docker >& /dev/null
  NODOCKER=$?
  if [ "${NODOCKER}" == 0 ]; then
	  echo "===> Pulling fabric Images"
	  dockerFabricPull ${FABRIC_TAG}
	  echo "===> Pulling fabric ca Image"
	  dockerCaPull ${CA_TAG}
	  echo "===> Pulling thirdparty docker images"
	  dockerThirdPartyImagesPull ${THIRDPARTY_TAG}
	  echo
	  echo "===> List out hyperledger docker images"
	  docker images | grep hyperledger*
  else
    echo "========================================================="
    echo "Docker not installed, bypassing download of Fabric images"
    echo "========================================================="
  fi
}

DOCKER=true
SAMPLES=true
BINARIES=true

# Parse commandline args pull out
# version and/or ca-version strings first
if [ ! -z "$1" -a ${1:0:1} != "-" ]; then
  VERSION=$1;shift
  if [ ! -z "$1"  -a ${1:0:1} != "-" ]; then
    CA_VERSION=$1;shift
    if [ ! -z "$1"  -a ${1:0:1} != "-" ]; then
      THIRDPARTY_IMAGE_VERSION=$1;shift
    fi
  fi
fi

# prior to 1.2.0 architecture was determined by uname -m
if [[ $VERSION =~ ^1\.[0-1]\.* ]]; then
  export FABRIC_TAG=${MARCH}-${VERSION}
  export CA_TAG=${MARCH}-${CA_VERSION}
  export THIRDPARTY_TAG=${MARCH}-${THIRDPARTY_IMAGE_VERSION}
else
  # starting with 1.2.0, multi-arch images will be default
  : ${CA_TAG:="$CA_VERSION"}
  : ${FABRIC_TAG:="$VERSION"}
  : ${THIRDPARTY_TAG:="$THIRDPARTY_IMAGE_VERSION"}
fi

BINARY_FILE=hyperledger-fabric-${ARCH}-${VERSION}.tar.gz
CA_BINARY_FILE=hyperledger-fabric-ca-${ARCH}-${CA_VERSION}.tar.gz

# then parse opts
while getopts "h?dsb" opt; do
  case "$opt" in
    h|\?)
      printHelp
      exit 0
    ;;
    d)  DOCKER=false
    ;;
    s)  SAMPLES=false
    ;;
    b)  BINARIES=false
    ;;
  esac
done

if [ "$SAMPLES" == "true" ]; then
  echo
  echo "Installing hyperledger/fabric-samples repo"
  echo
  samplesInstall
fi
if [ "$BINARIES" == "true" ]; then
  echo
  echo "Installing Hyperledger Fabric binaries"
  echo
  binariesInstall
fi
if [ "$DOCKER" == "true" ]; then
  echo
  echo "Installing Hyperledger Fabric docker images"
  echo
  dockerInstall
fi
```

查看其指令如下所示：

```BASH
$ ./bootstrap.sh --help
./bootstrap.sh: illegal option -- -
Usage: bootstrap.sh [version [ca_version [thirdparty_version]]] [options]

options:
-h : this help
-d : bypass docker image download
-s : bypass fabric-samples repo clone
-b : bypass download of platform-specific binaries

e.g. bootstrap.sh 1.4.4 -s
would download docker images and binaries for version 1.4.4
```

这里我们只需下载fabric的二进制文件，所以不需要其教程案例和docker镜像文件。

```BASH
chmod +x bootstrap.sh  # 赋予脚本可执行权限
./bootstrap.sh -s -d   # 只下载二进制文件
```

下载完成后，目录如下方所示：

```BASH
|-- bin
|   |-- configtxgen
|   |-- configtxlator
|   |-- cryptogen
|   |-- discover
|   |-- fabric-ca-client
|   |-- fabric-ca-server
|   |-- idemixgen
|   |-- orderer
|   |-- peer
|-- bootstrap.sh
|-- config
    |-- configtx.yaml
    |-- core.yaml
    |-- orderer.yaml
```

> `/bin`内文件是fabric核心模块的二进制文件，`/config`内文件是配置文件模版

现在，将`/bin`文件夹里的文件复制到`/usr/bin/local`中（该路径相对于系统路径）

> 目的是将fabric的`/bin`内的可执行文件在系统任何地方都可以直接执行，而不需要指定路径或者为这些可执行文件创建[软链接](https://www.linuxprobe.com/linux-ln.html)

```BASH
cp bin/* /usr/local/bin/
```

用`version`指令检查是否导入成功（注意：`configtxgen`需要用`--version`检查），结果如下，则表示成功：

```bash
root@localhost ReviewCode $ peer version
peer:
 Version: 1.4.9
 Commit SHA: da55272a7
 Go version: go1.13.12
 OS/Arch: linux/amd64
 Chaincode:
  Base Image Version: 0.4.21
  Base Docker Namespace: hyperledger
  Base Docker Label: org.hyperledger.fabric
  Docker Namespace: hyperledger

root@localhost ReviewCode $ configtxlator version
configtxlator:
 Version: 1.4.9
 Commit SHA: da55272a7
 Go version: go1.13.12
 OS/Arch: linux/amd64
root@localhost ReviewCode $ orderer version
orderer:
 Version: 1.4.9
 Commit SHA: da55272a7
 Go version: go1.13.12
 OS/Arch: linux/amd64

root@localhost ReviewCode $ cryptogen version
cryptogen:
 Version: 1.4.9
 Commit SHA: da55272a7
 Go version: go1.13.12
 OS/Arch: linux/amd64
root@localhost ReviewCode $ configtxgen --version
configtxgen:
 Version: 1.4.9
 Commit SHA: da55272a7
 Go version: go1.13.12
 OS/Arch: linux/amd64
```

至此，fabric几个重要模块安装成功。

第一步为我们的各种网络实体生成证书和秘钥。创世区块 `genesis block` 用于引导排序服务，也包含了一组配置 Channel 所需要的配置交易集合。

# 生成密钥材料（证书）

## 密钥生成器 cryptogen

> 我们将使用 `cryptogen` 工具为我们的网络实体生成各种加密材料（ x509 证书和签名秘钥）。这些证书是身份的代表，在实体之间通信和交易的时候，它们允许对身份验证进行签名和验证。`cryptogen`[命令参考](https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/commands/cryptogen.html)
>
> **该工具是如何工作的？**
>
> Cryptogen 通过一个包含网络拓扑的文件 `如crypto-config.yaml`，为所有组织和属于这些组织的组件生成一组证书和秘钥。每一个组织被分配一个唯一的根证书（`ca-cert`），它绑定该组织的特定组件（Peer 节点和排序节点）。通过为每个组织分配一个唯一的 CA 证书，我们模拟了一个典型的网络，网络中的成员可以使用它自己的证书授权中心。Fabric 中的事务和通信由一个实体的私钥（`keystore`）签名，然后通过公钥（`signcerts`）验证。[参考](https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/build_network.html?highlight=Genesis#id9)

首先暂时生成几个环境变量，

```BASH
export FABRIC_PROJECT_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric
export FABRIC_CFG_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig
```

创建密钥配置文件，命名为`cryptogen_config.yaml`，该配置文件定义了orderer和peer的基本信息。

```BASH
root@localhost fabricconfig $ cd $FABRIC_CFG_PATH  # 进入配置文件的目录
root@localhost fabricconfig $ touch cryptogen_config.yaml # 创建密钥的配置模板

# 编写文件见下方提示...

root@localhost fabricconfig $ cryptogen generate --config=cryptogen_config.yaml --output="../crypto-config"
#   --config 指明使用的配置模板的路径，--output指明生成证书文件的输出路径
org1.dy
org2.dy
org3.dy
org4.dy
```

> 可通过`cryptogen showtemplate`显示默认配置模板。

## 证书配置文件解析指路

`cryptogen_config.yaml`代码+分析=>[详情](./项目文件分析/证书配置文件.md)

至此，证书生成完毕，此时的项目目录结构如下所示：

```bash
root@localhost fabric $ tree -L 3
.
├── crypto-config
│   ├── ordererOrganizations
│   │   └── dy
│   └── peerOrganizations
│       ├── org1.dy
│       ├── org2.dy
│       ├── org3.dy
│       └── org4.dy
└── fabricconfig
    └── cryptogen_config.yaml
```

另外，需要在本机上修改下`hosts`

在`/etc/hosts`中新增如下五行：

```BASH
127.0.0.1 orderer.dy
127.0.0.1 peer0.org1.dy
127.0.0.1 peer0.org2.dy
127.0.0.1 peer0.org3.dy
127.0.0.1 peer0.org4.dy
```

# 生成创世区块

## 配置交易生成器 configtxgen

```BASH
cd $FABRIC_PROJECT_PATH   # 进入项目路径
mkdir order       #创建order文件夹

cd $FABRIC_CFG_PATH  # 进入配置文件路径
# 拷贝configtx.yaml配置文件进来
```

该`configtx.yaml`配置文件可以在GitHub仓库中找到模板（v1.4[链接](https://github.com/hyperledger/fabric/blob/release-1.4/sampleconfig/configtx.yaml)），

## 组织、通道配置文件解析指路

> `configtx.yaml`是Hyperledger Fabric区块链网络运维工具`configtxgen`用于生成**系统通道创世块**（genesis.block）或**通道交易配置文件**（mychannel.tx）
>
> `configtx.yaml`的内容直接决定了所生成的创世区块的内容。

`configtx.yaml`代码+分析=>[详情](./项目文件分析/configtx配置文件.md)







