> 本文档为农产品溯源项目源码解析（使用单节点部署）
>
> 单机多节点部署：https://blog.csdn.net/guoqingshuang/article/details/89153147

# 下载fabric

获取fabric安装的脚本文件，该脚本为1.4版本（第一个LTS版本，现在为2.X）。

```bash
curl -sSL https://raw.githubusercontent.com/hyperledger/fabric/release-1.4/scripts/bootstrap.sh
```

> 上方链接需翻墙才可下载，替代方法为找到该仓库的[源文件](https://github.com/hyperledger/fabric/blob/release-1.4/scripts/bootstrap.sh)新建`.sh`后缀文件将源码粘贴。
>
> 坑点：由于1.4版本源码中所展示的网站`nexus.hyperledger.org`不再维护，`2.0.0`之后的版本都是从GitHub上直接下载了（[参考](https://blog.csdn.net/qq_39800434/article/details/105094313/)）。所以运行脚本`bootstrap.sh`修改为如下：
>
> * 笔者将GitHub地址用国内镜像代替（`github.com.cnpmjs.org`）

```BASH
#!/bin/bash
#
# Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
#

# if version not passed in, default to latest released version
export VERSION=1.4.9
# if ca version not passed in, default to latest released version
export CA_VERSION=1.4.9
# current version of thirdparty images (couchdb, kafka and zookeeper) released
export THIRDPARTY_IMAGE_VERSION=0.4.21
export ARCH=$(echo "$(uname -s|tr '[:upper:]' '[:lower:]'|sed 's/mingw64_nt.*/windows/')-$(uname -m | sed 's/x86_64/amd64/g')")
export MARCH=$(uname -m)

printHelp() {
  echo "Usage: bootstrap.sh [version [ca_version [thirdparty_version]]] [options]"
  echo
  echo "options:"
  echo "-h : this help"
  echo "-d : bypass docker image download"
  echo "-s : bypass fabric-samples repo clone"
  echo "-b : bypass download of platform-specific binaries"
  echo
  echo "e.g. bootstrap.sh 1.4.9 -s"
  echo "would download docker images and binaries for version 1.4.9"
}

dockerFabricPull() {
  local FABRIC_TAG=$1
  for IMAGES in peer orderer ccenv javaenv tools; do
      echo "==> FABRIC IMAGE: $IMAGES"
      echo
      docker pull hyperledger/fabric-$IMAGES:$FABRIC_TAG
      docker tag hyperledger/fabric-$IMAGES:$FABRIC_TAG hyperledger/fabric-$IMAGES
  done
}

dockerThirdPartyImagesPull() {
  local THIRDPARTY_TAG=$1
  for IMAGES in couchdb kafka zookeeper; do
      echo "==> THIRDPARTY DOCKER IMAGE: $IMAGES"
      echo
      docker pull hyperledger/fabric-$IMAGES:$THIRDPARTY_TAG
      docker tag hyperledger/fabric-$IMAGES:$THIRDPARTY_TAG hyperledger/fabric-$IMAGES
  done
}

dockerCaPull() {
      local CA_TAG=$1
      echo "==> FABRIC CA IMAGE"
      echo
      docker pull hyperledger/fabric-ca:$CA_TAG
      docker tag hyperledger/fabric-ca:$CA_TAG hyperledger/fabric-ca
}

samplesInstall() {
  # clone (if needed) hyperledger/fabric-samples and checkout corresponding
  # version to the binaries and docker images to be downloaded
  if [ -d first-network ]; then
    # if we are in the fabric-samples repo, checkout corresponding version
    echo "===> Checking out v${VERSION} of hyperledger/fabric-samples"
    git checkout v${VERSION}
  elif [ -d fabric-samples ]; then
    # if fabric-samples repo already cloned and in current directory,
    # cd fabric-samples and checkout corresponding version
    echo "===> Checking out v${VERSION} of hyperledger/fabric-samples"
    cd fabric-samples && git checkout v${VERSION}
  else
    echo "===> Cloning hyperledger/fabric-samples repo and checkout v${VERSION}"
    git clone -b master https://github.com.cnpmjs.org/hyperledger/fabric-samples.git && cd fabric-samples && git checkout v${VERSION}
  fi
}

# Incrementally downloads the .tar.gz file locally first, only decompressing it
# after the download is complete. This is slower than binaryDownload() but
# allows the download to be resumed.
binaryIncrementalDownload() {
      local BINARY_FILE=$1
      local URL=$2
      curl -f -s -C -L --retry 5 --retry-delay 3 - ${URL} -o ${BINARY_FILE} || rc=$?
      # Due to limitations in the current Nexus repo:
      # curl returns 33 when there's a resume attempt with no more bytes to download
      # curl returns 2 after finishing a resumed download
      # with -f curl returns 22 on a 404
      if [ "$rc" = 22 ]; then
	  # looks like the requested file doesn't actually exist so stop here
	  return 22
      fi
      if [ -z "$rc" ] || [ $rc -eq 33 ] || [ $rc -eq 2 ]; then
          # The checksum validates that RC 33 or 2 are not real failures
          echo "==> File downloaded. Verifying the md5sum..."
              tar xzf ./${BINARY_FILE} --overwrite
      else
          echo "Failure downloading binaries (curl RC=$rc). Please try again and the download will resume from where it stopped."
          exit 1
      fi
}

# This will attempt to download the .tar.gz all at once, but will trigger the
# binaryIncrementalDownload() function upon a failure, allowing for resume
# if there are network failures.
binaryDownload() {
      local BINARY_FILE=$1
      local URL=$2
      echo "===> Downloading: " ${URL}
      # Check if a previous failure occurred and the file was partially downloaded
      if [ -e ${BINARY_FILE} ]; then
          echo "==> Partial binary file found. Resuming download..."
          binaryIncrementalDownload ${BINARY_FILE} ${URL}
      else
          curl -L --retry 5 --retry-delay 3 ${URL} | tar xz || rc=$?
          if [ ! -z "$rc" ]; then
              echo "==> There was an error downloading the binary file. Switching to incremental download."
              echo "==> Downloading file..."
              binaryIncrementalDownload ${BINARY_FILE} ${URL}
	  else
	      echo "==> Done."
          fi
      fi
}

binariesInstall() {
  echo "===> Downloading version ${FABRIC_TAG} platform specific fabric binaries"
  binaryDownload ${BINARY_FILE} https://github.com.cnpmjs.org/hyperledger/fabric/releases/download/v${VERSION}/${BINARY_FILE}
  if [ $? -eq 22 ]; then
     echo
     echo "------> ${FABRIC_TAG} platform specific fabric binary is not available to download <----"
     echo
   fi

  echo "===> Downloading version ${CA_TAG} platform specific fabric-ca-client binary"
  binaryDownload ${CA_BINARY_FILE} https://github.com.cnpmjs.org/hyperledger/fabric-ca/releases/download/v${CA_VERSION}/${CA_BINARY_FILE}
  if [ $? -eq 22 ]; then
     echo
     echo "------> ${CA_TAG} fabric-ca-client binary is not available to download  (Available from 1.1.0-rc1) <----"
     echo
   fi
}

dockerInstall() {
  which docker >& /dev/null
  NODOCKER=$?
  if [ "${NODOCKER}" == 0 ]; then
	  echo "===> Pulling fabric Images"
	  dockerFabricPull ${FABRIC_TAG}
	  echo "===> Pulling fabric ca Image"
	  dockerCaPull ${CA_TAG}
	  echo "===> Pulling thirdparty docker images"
	  dockerThirdPartyImagesPull ${THIRDPARTY_TAG}
	  echo
	  echo "===> List out hyperledger docker images"
	  docker images | grep hyperledger*
  else
    echo "========================================================="
    echo "Docker not installed, bypassing download of Fabric images"
    echo "========================================================="
  fi
}

DOCKER=true
SAMPLES=true
BINARIES=true

# Parse commandline args pull out
# version and/or ca-version strings first
if [ ! -z "$1" -a ${1:0:1} != "-" ]; then
  VERSION=$1;shift
  if [ ! -z "$1"  -a ${1:0:1} != "-" ]; then
    CA_VERSION=$1;shift
    if [ ! -z "$1"  -a ${1:0:1} != "-" ]; then
      THIRDPARTY_IMAGE_VERSION=$1;shift
    fi
  fi
fi

# prior to 1.2.0 architecture was determined by uname -m
if [[ $VERSION =~ ^1\.[0-1]\.* ]]; then
  export FABRIC_TAG=${MARCH}-${VERSION}
  export CA_TAG=${MARCH}-${CA_VERSION}
  export THIRDPARTY_TAG=${MARCH}-${THIRDPARTY_IMAGE_VERSION}
else
  # starting with 1.2.0, multi-arch images will be default
  : ${CA_TAG:="$CA_VERSION"}
  : ${FABRIC_TAG:="$VERSION"}
  : ${THIRDPARTY_TAG:="$THIRDPARTY_IMAGE_VERSION"}
fi

BINARY_FILE=hyperledger-fabric-${ARCH}-${VERSION}.tar.gz
CA_BINARY_FILE=hyperledger-fabric-ca-${ARCH}-${CA_VERSION}.tar.gz

# then parse opts
while getopts "h?dsb" opt; do
  case "$opt" in
    h|\?)
      printHelp
      exit 0
    ;;
    d)  DOCKER=false
    ;;
    s)  SAMPLES=false
    ;;
    b)  BINARIES=false
    ;;
  esac
done

if [ "$SAMPLES" == "true" ]; then
  echo
  echo "Installing hyperledger/fabric-samples repo"
  echo
  samplesInstall
fi
if [ "$BINARIES" == "true" ]; then
  echo
  echo "Installing Hyperledger Fabric binaries"
  echo
  binariesInstall
fi
if [ "$DOCKER" == "true" ]; then
  echo
  echo "Installing Hyperledger Fabric docker images"
  echo
  dockerInstall
fi
```

查看其指令如下所示：

```BASH
$ ./bootstrap.sh --help
./bootstrap.sh: illegal option -- -
Usage: bootstrap.sh [version [ca_version [thirdparty_version]]] [options]

options:
-h : this help
-d : bypass docker image download
-s : bypass fabric-samples repo clone
-b : bypass download of platform-specific binaries

e.g. bootstrap.sh 1.4.4 -s
would download docker images and binaries for version 1.4.4
```

这里我们只需下载fabric的二进制文件，所以不需要其教程案例和docker镜像文件。

```BASH
chmod +x bootstrap.sh  # 赋予脚本可执行权限
./bootstrap.sh -s -d   # 只下载二进制文件
```

下载完成后，目录如下方所示：

```BASH
|-- bin
|   |-- configtxgen
|   |-- configtxlator
|   |-- cryptogen
|   |-- discover
|   |-- fabric-ca-client
|   |-- fabric-ca-server
|   |-- idemixgen
|   |-- orderer
|   |-- peer
|-- bootstrap.sh
|-- config
    |-- configtx.yaml
    |-- core.yaml
    |-- orderer.yaml
```

> `/bin`内文件是fabric核心模块的二进制文件，`/config`内文件是配置文件模版

现在，将`/bin`文件夹里的文件复制到`/usr/bin/local`中（该路径相对于系统路径）

> 目的是将fabric的`/bin`内的可执行文件在系统任何地方都可以直接执行，而不需要指定路径或者为这些可执行文件创建[软链接](https://www.linuxprobe.com/linux-ln.html)

## 导入Path

```BASH
cp bin/* /usr/local/bin/
```

用`version`指令检查是否导入成功（注意：`configtxgen`需要用`--version`检查），结果如下，则表示成功：

```bash
root@localhost ReviewCode $ peer version
peer:
 Version: 1.4.9
 Commit SHA: da55272a7
 Go version: go1.13.12
 OS/Arch: linux/amd64
 Chaincode:
  Base Image Version: 0.4.21
  Base Docker Namespace: hyperledger
  Base Docker Label: org.hyperledger.fabric
  Docker Namespace: hyperledger

root@localhost ReviewCode $ configtxlator version
configtxlator:
 Version: 1.4.9
 Commit SHA: da55272a7
 Go version: go1.13.12
 OS/Arch: linux/amd64
root@localhost ReviewCode $ orderer version
orderer:
 Version: 1.4.9
 Commit SHA: da55272a7
 Go version: go1.13.12
 OS/Arch: linux/amd64

root@localhost ReviewCode $ cryptogen version
cryptogen:
 Version: 1.4.9
 Commit SHA: da55272a7
 Go version: go1.13.12
 OS/Arch: linux/amd64
root@localhost ReviewCode $ configtxgen --version
configtxgen:
 Version: 1.4.9
 Commit SHA: da55272a7
 Go version: go1.13.12
 OS/Arch: linux/amd64
```

至此，fabric几个重要模块安装成功。

## 安装go

```BASH
# 将go下载到创建好的目录中
wget https://dl.google.com/go/go1.14.3.linux-amd64.tar.gz

#解压到/usr/local（官方推荐）
sudo tar -C /usr/local -zxvf go1.14.3.linux-amd64.tar.gz

# 添加/usr/local/go/bin目录到PATH变量中，可以添加到/etc/profile 
vi /etc/profile

##在末尾添加如下两行
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin

# 运行source命令使其生效
source /etc/profile

```



第一步为我们的各种网络实体生成证书和秘钥。创世区块 `genesis block` 用于引导排序服务，也包含了一组配置 Channel 所需要的配置交易集合。

# 1. 生成证书（密钥材料）

## 密钥生成器 cryptogen

> 我们将使用 `cryptogen` 工具为我们的网络实体生成各种加密材料（ x509 证书和签名秘钥）。这些证书是身份的代表，在实体之间通信和交易的时候，它们允许对身份验证进行签名和验证。`cryptogen`[命令参考](https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/commands/cryptogen.html)
>
> **该工具是如何工作的？**
>
> Cryptogen 通过一个包含网络拓扑的文件 `如crypto-config.yaml`，为所有组织和属于这些组织的组件生成一组证书和秘钥。每一个组织被分配一个唯一的根证书（`ca-cert`），它绑定该组织的特定组件（Peer 节点和排序节点）。通过为每个组织分配一个唯一的 CA 证书，我们模拟了一个典型的网络，网络中的成员可以使用它自己的证书授权中心。Fabric 中的事务和通信由一个实体的私钥（`keystore`）签名，然后通过公钥（`signcerts`）验证。[参考](https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/build_network.html?highlight=Genesis#id9)

首先暂时生成几个环境变量

### 设置项目环境变量

注意：<u>export 的效力仅限于该次登陆操作</u>，所以每次登陆都要运行下方命令。

```BASH
export FABRIC_PROJECT_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric
export FABRIC_CFG_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig
```

创建密钥配置文件，命名为`cryptogen_config.yaml`，该配置文件定义了orderer和peer的基本信息。

```BASH
root@localhost fabricconfig $ cd $FABRIC_CFG_PATH  # 进入配置文件的目录
root@localhost fabricconfig $ touch cryptogen_config.yaml # 创建密钥的配置模板

# 编写文件见下方提示...

root@localhost fabricconfig $ cryptogen generate --config=cryptogen_config.yaml --output="./crypto-config"
#   --config 指明使用的配置模板的路径，--output指明生成证书文件的输出路径
org1.dy
org2.dy
org3.dy
org4.dy
```

> **注意**：生成的证书文件夹建议放在`fabricconfig`也就是`./crypto-config`目录下，而不是`../crypto-config`，原因见下方[目录路径问题](######目录路径问题)
>
> 可通过`cryptogen showtemplate`显示默认配置模板。

## 证书配置文件解析指路

`cryptoge-config.yaml`代码+分析=>[详情](./项目文件分析/crypto-config证书配置文件.md)

至此，证书生成完毕，此时的项目目录结构如下所示：

```bash
root@localhost fabric $ tree -L 3
.
├── crypto-config
│   ├── ordererOrganizations
│   │   └── dy
│   └── peerOrganizations
│       ├── org1.dy
│       ├── org2.dy
│       ├── org3.dy
│       └── org4.dy
└── fabricconfig
    └── cryptogen-config.yaml
##### 更新后见下方 #####
# 也就是将证书目录放入fabricconfig下方了
root@localhost fabric $ tree -L 3
.
├── fabricconfig
│   ├── configtx.yaml
│   ├── crypto-config
│   │   ├── ordererOrganizations
│   │   └── peerOrganizations
│   └── cryptogen-config.yaml
```

另外，需要在本机上修改下`hosts`

在`/etc/hosts`中新增如下五行：

```BASH
127.0.0.1 orderer.dy
127.0.0.1 peer0.org1.dy
127.0.0.1 peer0.org2.dy
127.0.0.1 peer0.org3.dy
127.0.0.1 peer0.org4.dy
```

# 2. 生成创世区块和Channel配置区块

## 配置交易生成器 configtxgen

> configtxgen 命令参考[链接](https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/commands/configtxgen.html?highlight=configtx.yaml#null)

```BASH
cd $FABRIC_PROJECT_PATH   # 进入项目路径

cd $FABRIC_CFG_PATH  # 进入配置文件路径
# 拷贝configtx.yaml配置文件（下方“详情”链接文档尾部-项目代码）
```

> 该`configtx.yaml`配置文件可以在GitHub仓库中找到模板（v1.4[链接](https://github.com/hyperledger/fabric/blob/release-1.4/sampleconfig/configtx.yaml)），

configtxgen工具生成的初始二进制通道配置定义 是一个包含Hyperledger Fabric配置`protobuf.common.Envelope`元素的二进制文件 。该元素内部是`common.ConfigUpdate.protobuf` 元素。此配置元素是必须签名的元素中的配置文件元素。`configtx.yaml`是由configtxgen工具创建的初始二进制通道配置定义的源。

## 组织、通道配置文件解析指路

> `configtx.yaml`是Hyperledger Fabric区块链网络运维工具`configtxgen`用于生成**系统通道创世块**（genesis.block）或**通道交易配置文件**（mychannel.tx）
>
> `configtx.yaml`的内容直接决定了所生成的创世区块的内容。

`configtx.yaml`代码+分析=>[详情](./项目文件分析/configtx配置文件.md)

> 注意：
>
> * 如果是多机部署，各个组织的`AnchorPeers`的Port可以统一写7061.
> * 如果要上Kafka，则需要改Orderer下的部分配置。等要上了再参照官方的模板考虑怎么改。

随后，我们使用`configtxgen`来生成创世块。

---

###### 目录路径问题

“`configtxgen` 工具的输出依赖于 `configtx.yaml`。`configtx.yaml` 可在 `FABRIC_CFG_PATH` 下找到，且在 `configtxgen` 执行时必须存在。“也就是说，运行前==必须设置该环境变量==(`FABRIC_CFG_PATH`)。

并且需要注意到`configtx.taml`文件中，定义`组织MSP文件证书路径`是相对于该环境变量的，也就是说如果设置` MSPDir: xxx`，则实际查找时是查找`$FABRIC_CFG_PATH/XXX$`。所以如果上方生成路径选择`../crypto-config`（也就是说证书生成文件夹与该配置文件文件夹是并列），那么`configtx.yaml`中需要设置成`MSPDir: ../xxx`。综合考虑，设置证书文件夹与配置文件在同级。

---

```bash
$ export FABRIC_CFG_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig 
# 不放心可以再设置一遍环境变量

# 排序通道创世区块
# configtxgen --help //查看生成创始区块的相关命令
# -profile 后边的参数从configtx.yaml中的Profiles 里边的配置项
# -outputBlock: 指定生成的创始区块文件
$ configtxgen -profile TestOrgsOrdererGenesis -channelID sys-channel -outputBlock $FABRIC_CFG_PATH/../orderer/orderer.genesis.block

# 创建通道配置交易
# 通道配置包含关于通道管理的所有信息。最重要的是，通道配置指定了哪些组织是通道的成员，但它也 包含其他的全通道的配置信息，例如，通道访问策略和区块的批处理大小。
# -outputCreateChannelTx: 指定通道文件的名字
# -channelID : 指定要生成的通道的通道名字
$ configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID mychannel

# 得到如下输出
2021-01-24 15:44:35.283 CST [common.tools.configtxgen] main -> INFO 001 Loading configuration
2021-01-24 15:44:35.365 CST [common.tools.configtxgen.localconfig] completeInitialization -> INFO 002 orderer type: solo
2021-01-24 15:44:35.365 CST [common.tools.configtxgen.localconfig] Load -> INFO 003 Loaded configuration: /home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig/configtx.yaml
2021-01-24 15:44:35.460 CST [common.tools.configtxgen.localconfig] completeInitialization -> INFO 004 orderer type: solo
2021-01-24 15:44:35.460 CST [common.tools.configtxgen.localconfig] LoadTopLevel -> INFO 005 Loaded configuration: /home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig/configtx.yaml
2021-01-24 15:44:35.460 CST [common.tools.configtxgen.encoder] NewChannelGroup -> WARN 006 Default policy emission is deprecated, please include policy specifications for the channel group in configtx.yaml
2021-01-24 15:44:35.461 CST [common.tools.configtxgen.encoder] NewOrdererOrgGroup -> WARN 007 Default policy emission is deprecated, please include policy specifications for the orderer org group OrdererOrg in configtx.yaml
2021-01-24 15:44:35.461 CST [common.tools.configtxgen.encoder] NewConsortiumOrgGroup -> WARN 008 Default policy emission is deprecated, please include policy specifications for the orderer org group Org1MSP in configtx.yaml
2021-01-24 15:44:35.461 CST [common.tools.configtxgen.encoder] NewConsortiumOrgGroup -> WARN 009 Default policy emission is deprecated, please include policy specifications for the orderer org group Org2MSP in configtx.yaml
2021-01-24 15:44:35.462 CST [common.tools.configtxgen.encoder] NewConsortiumOrgGroup -> WARN 00a Default policy emission is deprecated, please include policy specifications for the orderer org group Org3MSP in configtx.yaml
2021-01-24 15:44:35.462 CST [common.tools.configtxgen.encoder] NewConsortiumOrgGroup -> WARN 00b Default policy emission is deprecated, please include policy specifications for the orderer org group Org4MSP in configtx.yaml
2021-01-24 15:44:35.462 CST [common.tools.configtxgen] doOutputBlock -> INFO 00c Generating genesis block
2021-01-24 15:44:35.463 CST [common.tools.configtxgen] doOutputBlock -> INFO 00d Writing genesis block
```

> configtxgen 指令标识(flag)说明:
>
> * `-outputBlock`参数指明了所要生成的创世块文件的路径。
> * `-profile`参数指明了从·文件中，该读取Profiles（配置入口）下的哪一个Profile，这里是`TestOrgsOrdererGenesis`.
> * `-channelID`指明了orderer自己系统通道的名字。在新版本中要求显式地指名，否则默认设成`testchainid`，并报一个WARN。

注意这里有几个WARN，主要是说默认背书策略(policy)已弃用。

* Policy是类似于`AND('A', 'B')`或者`OR('A','B')`的字符串，它定义了某个操作需要遵循何种规则由哪些组织背书才能通过。
* 按照官方推荐的做法，需要在生成创世块时就定义好一部分Policy。但是，我们目前只需要chaincode层面的Policy，这个可以在后面建立chaincode的时候再设置。

> 所谓chaincode层面的Policy，举个例子。
> 对于某chaincode，有Policy为AND('A', 'B')。则这个chaincode上的所有事务的提案都必须同时得到A和B的背书才能被承认。
>
> 而对于同时得到A和B的背书，实现方式是：A和B上实例化同样的chaincode，外部服务器的同时给A，B发同样的grpc请求调用chaincode。

总之，在运行了configtxgen之后，如果成功，就已经生成了创世块。
如同它参数中`-outputBlock ./channel-artifacts/orderer.genesis.block`所指明的，在`channel-artifacts`目录下会有一个`orderer.genesis.block`文件。这就是创世块。

可通过下方命令查看该创始区块的内容，内容是一长串JSON字符串。

```BASH
configtxgen -inspectBlock ../orderer/orderer.genesis.block  # 该flag作业：打印指定路径的区块中包含的配置。
```

查看当前目录：

```BASH
root@localhost fabric $ tree -L 4
.
├── fabricconfig
│   ├── configtx.yaml
│   ├── crypto-config
│   │   ├── ordererOrganizations
│   │   │   └── dy
│   │   └── peerOrganizations
│   │       ├── org1.dy
│   │       ├── org2.dy
│   │       ├── org3.dy
│   │       └── org4.dy
│   ├── cryptogen_config.yaml
├── orderer
│   └── orderer.genesis.block
```

# 3.配置Fabric环境的docker-compose文件

## 3.1 配置Orderer节点

在`$FABRIC_CFG_PATH`目录下放入`orderer.yaml`文件，官方[模版](https://github.com/hyperledger/fabric/blob/release-1.4/sampleconfig/orderer.yaml)，修改后的源码请看下方指路文件中-项目代码

该文件是orderer节点的配置，当`orderer start`时，会从`$FABRIC_CFG_PATH`中找到并读取这个文件。

> 注意，文件名必须是`orderer.yaml`。orderer start只认这个名字。

### Orderer配置文件解析指路

`orderer.yaml`代码+分析=>[详情](./项目文件分析/orderer配置文件.md)

对于该文件，需要注意：

* `General.ListenPort`必须和`configtx.yaml`中的`Orderer.Addresses`的端口相同。这里是7050。
* `General.Cluster`等到多orderer时再考虑怎么配置。
* `General.LocalMSPID`主要是在channel相关操作用来指明orderer的。
* `FileLedger.Location`指明了账本的存储位置。这里设置在了`$FABRIC_CFG_PATH/order/production/orderer`。
* `Kafka`下各项保留了默认配置，等上多Orderer时再考虑怎么配。
* `Operations`和`Metrics`两栏是新功能，向外暴露运营API，包括日志管理健康检查啥的，有需要再配。
* `Consensus`是有`kafka`以外的其他共识协议插件时需要的配置，有需要再说。

以下各项使用的路径同[之前](######目录路径问题)所说类似，默认路径都为`$FABRIC_CFG_PATH`，所以设置时需注意是在路径之下

- General.TLS
- General.GenesisFile
- General.LocalMSPDir
- FileLedger.Location

配置完一切就可以启动orderer结点，注意需要设置环境变量`FABRIC_CFG_PATH`。

```BASH
export FABRIC_CFG_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig
orderer start

### 输出如下 ###
2021-01-24 18:48:36.132 CST [localconfig] completeInitialization -> INFO 001 Kafka.Version unset, setting to 0.10.2.0
2021-01-24 18:48:36.168 CST [orderer.common.server] prettyPrintStruct -> INFO 002 Orderer config values:
	General.LedgerType = "file"
	General.ListenAddress = "0.0.0.0"
	General.ListenPort = 7050
	General.TLS.Enabled = false
	General.TLS.PrivateKey = "/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig/crypto-config/ordererOrganizations/dy/orderers/orderer.dy/tls/server.key"
	General.TLS.Certificate = "/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig/crypto-config/ordererOrganizations/dy/orderers/orderer.dy/tls/server.crt"
	General.TLS.RootCAs = [/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig/crypto-config/ordererOrganizations/dy/orderers/orderer.dy/tls/ca.crt]
# ...... 节省篇幅，故截断部分 ......
2021-01-24 18:48:36.317 CST [orderer.common.server] extractSysChanLastConfig -> INFO 003 Bootstrapping because no existing channels
2021-01-24 18:48:36.329 CST [certmonitor] trackCertExpiration -> INFO 004 The enrollment certificate will expire on 2031-01-20 06:06:00 +0000 UTC
2021-01-24 18:48:36.352 CST [fsblkstorage] newBlockfileMgr -> INFO 005 Getting block information from block storage
2021-01-24 18:48:36.481 CST [orderer.commmon.multichannel] Initialize -> INFO 006 Starting system channel 'ordererchannel' with genesis block hash 0ad4ee8cdc9225f9158bd470be37758cfea9fa394f9271de3aa4d471206532bc and orderer type solo
2021-01-24 18:48:36.481 CST [orderer.common.server] Start -> INFO 007 Starting orderer:
 Version: 1.4.9
 Commit SHA: da55272a7
 Go version: go1.13.12
 OS/Arch: linux/amd64
2021-01-24 18:48:36.481 CST [orderer.common.server] Start -> INFO 008 Beginning to serve requests
```

看见输出没有报错，则orderer结点启动成功。会在目录`orderer/`下生成一个`production`文件夹，里面有orderer的ledger。这个配置项在`orderer.yaml`的`FileLedger`中。

```BASH
root@localhost fabric # tree -L 3
.
├── fabricconfig
│   ├── configtx.yaml
│   ├── crypto-config
│   │   ├── ordererOrganizations
│   │   └── peerOrganizations
│   ├── cryptogen_config.yaml
│   └── orderer.yaml
├── orderer
│   ├── orderer.genesis.block
│   └── production
│       ├── chains
│       └── index
```

## 3.2 启动Peers节点

### Peer1

```BASH
cd $FABRIC_CFG_PATH
放入core.yaml文件
```

`core.yaml`是peer节点的配置文件。注意，文件名必须是`core.yaml`，`peer node start`默认接受这个名字。

### Peer配置文件解析指路

`core.yaml`代码+分析=>[详情](./项目文件分析/peer配置文件.md)

粘贴完该配置文件，进行启动

```BASH
$ export FABRIC_CFG_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig # 运行前必须保证该环境变量正确，因为下方命令默认会前往该路径寻找core.yaml

$ mkdir peer1  # 在fabric/目录下生成一个文件夹，这将会是存储peer1节点的相关文件的路径

$ peer node start
```

输出如下所示：

```BASH
2021-01-25 11:05:41.368 CST [nodeCmd] serve -> INFO 001 Starting peer:
 Version: 1.4.9
 Commit SHA: da55272a7
 Go version: go1.13.12
 OS/Arch: linux/amd64
 Chaincode:
  Base Image Version: 0.4.21
  Base Docker Namespace: hyperledger
  Base Docker Label: org.hyperledger.fabric
  Docker Namespace: hyperledger
2021-01-25 11:05:41.369 CST [ledgermgmt] initialize -> INFO 002 Initializing ledger mgmt
2021-01-25 11:05:41.369 CST [kvledger] NewProvider -> INFO 003 Initializing ledger provider
2021-01-25 11:05:41.625 CST [kvledger] NewProvider -> INFO 004 ledger provider Initialized
2021-01-25 11:05:42.046 CST [ledgermgmt] initialize -> INFO 005 ledger mgmt initialized
2021-01-25 11:05:42.047 CST [peer] func1 -> INFO 006 Auto-detected peer address: 192.168.1.102:7061
2021-01-25 11:05:42.048 CST [peer] func1 -> INFO 007 Returning peer0.org1.dy:7061
2021-01-25 11:05:42.048 CST [peer] func1 -> INFO 008 Auto-detected peer address: 192.168.1.102:7061
2021-01-25 11:05:42.049 CST [peer] func1 -> INFO 009 Returning peer0.org1.dy:7061
2021-01-25 11:05:42.052 CST [nodeCmd] computeChaincodeEndpoint -> INFO 00a Entering computeChaincodeEndpoint with peerHostname: peer0.org1.dy
2021-01-25 11:05:42.052 CST [nodeCmd] computeChaincodeEndpoint -> INFO 00b Exit with ccEndpoint: peer0.org1.dy:7041
2021-01-25 11:05:42.056 CST [sccapi] registerSysCC -> INFO 00c system chaincode lscc(github.com/hyperledger/fabric/core/scc/lscc) registered
2021-01-25 11:05:42.056 CST [sccapi] registerSysCC -> INFO 00d system chaincode cscc(github.com/hyperledger/fabric/core/scc/cscc) registered
2021-01-25 11:05:42.056 CST [sccapi] registerSysCC -> INFO 00e system chaincode qscc(github.com/hyperledger/fabric/core/scc/qscc) registered
2021-01-25 11:05:42.056 CST [sccapi] registerSysCC -> INFO 00f system chaincode (+lifecycle,github.com/hyperledger/fabric/core/chaincode/lifecycle,true) disabled
2021-01-25 11:05:42.061 CST [certmonitor] trackCertExpiration -> INFO 010 The enrollment certificate will expire on 2031-01-20 06:06:00 +0000 UTC
2021-01-25 11:05:42.062 CST [gossip.service] func1 -> INFO 011 Initialize gossip with endpoint peer0.org1.dy:7061 and bootstrap set [peer0.org1.dy:7061]
2021-01-25 11:05:42.088 CST [gossip.gossip] NewGossipService -> INFO 012 Creating gossip service with self membership of Endpoint: peer0.org1.dy:7061, InternalEndpoint: peer0.org1.dy:7061, PKI-ID: 59de6be3aa43f6c23c2a00e18a2df2cae756fcf80e9194c4685ddcc35eec35a8, Metadata: 
2021-01-25 11:05:42.088 CST [gossip.gossip] start -> INFO 013 Gossip instance peer0.org1.dy:7061 started
2021-01-25 11:05:42.089 CST [sccapi] deploySysCC -> INFO 014 system chaincode lscc/(github.com/hyperledger/fabric/core/scc/lscc) deployed
2021-01-25 11:05:42.089 CST [cscc] Init -> INFO 015 Init CSCC
2021-01-25 11:05:42.089 CST [sccapi] deploySysCC -> INFO 016 system chaincode cscc/(github.com/hyperledger/fabric/core/scc/cscc) deployed
2021-01-25 11:05:42.090 CST [qscc] Init -> INFO 017 Init QSCC
2021-01-25 11:05:42.090 CST [sccapi] deploySysCC -> INFO 018 system chaincode qscc/(github.com/hyperledger/fabric/core/scc/qscc) deployed
2021-01-25 11:05:42.090 CST [sccapi] deploySysCC -> INFO 019 system chaincode (+lifecycle,github.com/hyperledger/fabric/core/chaincode/lifecycle) disabled
2021-01-25 11:05:42.090 CST [nodeCmd] serve -> INFO 01a Deployed system chaincodes
2021-01-25 11:05:42.092 CST [discovery] NewService -> INFO 01b Created with config TLS: false, authCacheMaxSize: 1000, authCachePurgeRatio: 0.750000
2021-01-25 11:05:42.092 CST [nodeCmd] registerDiscoveryService -> INFO 01c Discovery service activated
2021-01-25 11:05:42.093 CST [nodeCmd] serve -> INFO 01d Starting peer with ID=[name:"peer0.org1.dy" ], network ID=[dev], address=[peer0.org1.dy:7061]
2021-01-25 11:05:42.093 CST [nodeCmd] serve -> INFO 01e Started peer with ID=[name:"peer0.org1.dy" ], network ID=[dev], address=[peer0.org1.dy:7061]
2021-01-25 11:05:42.094 CST [kvledger] LoadPreResetHeight -> INFO 01f Loading prereset height from path [/home/dongyangyu/ReviewCode/workSpace/fabric/production/peer1/ledgersData/chains]
2021-01-25 11:05:42.094 CST [fsblkstorage] LoadPreResetHeight -> INFO 020 Loading Pre-reset heights
2021-01-25 11:05:42.094 CST [fsblkstorage] preRestHtFiles -> INFO 021 Dir [/home/dongyangyu/ReviewCode/workSpace/fabric/production/peer1/ledgersData/chains/chains] missing... exiting
2021-01-25 11:05:42.094 CST [fsblkstorage] LoadPreResetHeight -> INFO 022 Pre-reset heights loaded
```

此时查看目录如下：

```BASH
root@localhost fabricconfig # tree ../ -L 3
../
├── fabricconfig
│   ├── configtx.yaml
│   ├── core.yaml
│   ├── crypto-config
│   │   ├── ordererOrganizations
│   │   └── peerOrganizations
│   ├── cryptogen_config.yaml
│   └── orderer.yaml
├── orderer
│   ├── orderer.genesis.block
│   └── production
│       ├── chains
│       └── index
└── peer1
    └── production
        └── ledgersData
```

### Peer2~4

复制`core.yaml`的内容再创建三个yaml文件，分别命名为`core2.yaml`，`core3.yaml`，`core4.yaml`，分别作为四个peer节点的部署文件。

```BASH
cp core.yaml core2.yaml
cp core.yaml core3.yaml
cp core.yaml core4.yaml
```

复制后需要修改配置里的`host, port, path`，需要注意以下属性：

* `peer.tls`，`peer.mspConfigPath`，`peer.localMspId`
  * 对应修改为peer的id，证书路径

下方`->`左边表示单机部署需分别修改的值，`->`右边表示多机部署时需要统一修改的值。

- `peer.listenAddress`，
  - 7061~4 -> 7051

* `peer.chaincodeListenAddress`
  * 7041~4 -> 7052

- `peer.address`
  - 7041~4 -> 7052
- `peer.gossip.bootstrap`
  - 7061~4 -> 7051
- `peer.gossip.externalEndpoint`
  - 7061~4 -> 7051
- `peer.fileSystemPath`
  - 创建文件夹`../production/peer1~4`->`../production/peer`
- `operations.listenAddress`
  - 9443~6 -> 9443
- 修改文件名
  - 依次修改2~4节点配置文件名为`core.yaml`。因为peer node start不认识`core2~4.yaml`，只认`core.yaml`。

修改完毕后，依次启动，但是依次启动时需要修改文件名为`core.yaml`，原因上面有提及。

> 注意：多机部署，`fabricconfig`文件夹只有peer自己的一个`core.yaml`文件，部署与Peer1的步骤相同。

下面列出单机部署四个节点的步骤（以peer2为例）：

```BASH
$ cd production
$ mkdir peer2    # 在production文件夹下建立peer2文件夹
$ export FABRIC_CFG_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig 	  # 如果未设置该CFG路径 需要设置环境变量

$ cd ../fabricconfig/  # 进入fabricconfig文件夹 进行修改core文件名

$ mv ../fabricconfig/core.yaml ../fabricconfig/core1.yaml #重命名
$ mv ../fabricconfig/core2.yaml ../fabricconfig/core.yaml

$ peer node start # 启动节点（peer2）
```

同理依次建立2，3，4。输出类似即成功，单机部署结束，项目结构如下所示：

```BASH
root@localhost fabricconfig # tree ../ -L 3
../
├── fabricconfig
│   ├── configtx.yaml
│   ├── core1.yaml
│   ├── core2.yaml
│   ├── core3.yaml
│   ├── core.yaml	# 这是原来的core4.yaml
│   ├── crypto-config
│   │   ├── ordererOrganizations
│   │   └── peerOrganizations
│   ├── cryptogen_config.yaml
│   └── orderer.yaml
├── orderer
│   ├── orderer.genesis.block
│   └── production
│       ├── chains
│       └── index
├── peer1
│   └── production
│       ├── chaincodes
│       └── ledgersData
├── peer2
│   └── production
│       ├── chaincodes
│       └── ledgersData
├── peer3
│   └── production
│       ├── chaincodes
│       └── ledgersData
└── peer4
    └── production
        ├── chaincodes
        └── ledgersData
```

# 4. 建立通道

## 4.1 在Org1和Org4之间建立通道

现在回看`fabricconfig`文件夹下的`configtx.yaml`。这是给`configtxgen`使用的配置文件。这里我们主要看`Organizations`和`Profiles`两大部分。

#### `configtx.yaml`内容回顾

##### **Organizations**内容

```yaml
Organizations:
    # Our orgs start from here
    - &OrdererOrg
        Name: OrdererOrg
        ID: OrdererMSP
        MSPDir: crypto-config/ordererOrganizations/dy/msp
    - &Org1
        Name: Org1MSP
        ID: Org1MSP
        MSPDir: crypto-config/peerOrganizations/org1.dy/msp
        AnchorPeers:
            - Host: peer0.org1.dy
              Port: 7061
    - &Org2
        Name: Org2MSP
        ID: Org2MSP
        MSPDir: crypto-config/peerOrganizations/org2.dy/msp
        AnchorPeers:
            - Host: peer0.org2.dy
              Port: 7062
    - &Org3
        Name: Org3MSP
        ID: Org3MSP
        MSPDir: crypto-config/peerOrganizations/org3.dy/msp
        AnchorPeers:
            - Host: peer0.org3.dy
              Port: 7063
    - &Org4
        Name: Org4MSP
        ID: Org4MSP
        MSPDir: crypto-config/peerOrganizations/org4.dy/msp
        AnchorPeers:
            - Host: peer0.org4.dy
              Port: 7064
```

Organizations里我们添加了对`Org1~4`和`OrdererOrg`的定义，这里注意下`Org1~4`的`AnchorPeers`的端口(Port)，因为是单机部署，所以错开为`7061~7064`，如果是多机部署，建议全部修改为`7051`。

##### **Profiles**

```YAML
Profiles:
    TestOrgsOrdererGenesis:
        Orderer:
            <<: *OrdererDefaults
            Organizations:
                - *OrdererOrg
        Consortiums:
            SampleConsortium:
                Organizations:
                    - *Org1
                    - *Org2
                    - *Org3
                    - *Org4
    TestOrgsChannel:
        Consortium: SampleConsortium
        Application:
            <<: *ApplicationDefaults
            Organizations:
                - *Org1
                - *Org2
                - *Org3
                - *Org4
    Org1Channel:
        Consortium: SampleConsortium
        Application:
            <<: *ApplicationDefaults
            Organizations:
                - *Org1
                - *Org4
    Org2Channel:
        Consortium: SampleConsortium
        Application:
            <<: *ApplicationDefaults
            Organizations:
                - *Org2
                - *Org4
    Org3Channel:
        Consortium: SampleConsortium
        Application:
            <<: *ApplicationDefaults
            Organizations:
                - *Org3
                - *Org4
```

在Profiles的最后，添加了对channel也就是通道的描述。此外的部分可先不管。

下面开始建立channel。在这一节只描述了建立Org1和Org4之间的一个channel，在Org2和Org4, Org3和Org4之间建立同理。

### 生成建立channel的提案文件 proposal

```BASH
export FABRIC_CFG_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig

configtxgen -profile Org1Channel -outputCreateChannelTx $FABRIC_CFG_PATH/../peer1/Org1Channel.tx -channelID org1channel

configtxgen -profile Org1Channel -outputAnchorPeersUpdate $FABRIC_CFG_PATH/../peer1/Org1MSPanchorsInOrg1Channel.tx -channelID org1channel -asOrg Org1MSP # 将配置更新交易输出到 Org1MSPanchorsInOrg1Channel.tx，就是将组织 Org1 的锚节点设置成 configtx.yaml 中轮廓 Org1Channel 所定义的。


```

>  `configtxgen`指令回顾：
>
> * `-profile`参数表示从`configtx.yaml`的`Profiles`属性中读入哪一个Profile，这个参数的值必须在`configtx.yaml`中。这部分在最尾部，我们只写了`Org1Channel~Org3Channel`。
>
> * `-outputCreateChannelTx`参数代表写入通道创建交易的输出路径
>
> * `-channelID`代表我们这个channel的ID。这个可以随便指定，但要前后一致。另外，<u>不能包含大写字母</u>。
>
> * `-outputAnchorPeersUpdate`代表更新锚节点这一交易的输出路径。锚节点是个逻辑概念，这里我们org1的锚节点就是peer0.org1.dy。
>
> * `-asOrg`参数代表是哪个组织。这里个值必须和`core.yaml`里的`localMspId`一致。这里是Org1MSP。
>
>   

输出结果分别如下：

```BASH
2021-01-25 17:49:53.467 CST [common.tools.configtxgen] main -> INFO 001 Loading configuration
2021-01-25 17:49:53.558 CST [common.tools.configtxgen.localconfig] Load -> INFO 002 Loaded configuration: /home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig/configtx.yaml
2021-01-25 17:49:53.632 CST [common.tools.configtxgen.localconfig] completeInitialization -> INFO 003 orderer type: solo
2021-01-25 17:49:53.632 CST [common.tools.configtxgen.localconfig] LoadTopLevel -> INFO 004 Loaded configuration: /home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig/configtx.yaml
2021-01-25 17:49:53.632 CST [common.tools.configtxgen] doOutputChannelCreateTx -> INFO 005 Generating new channel configtx
2021-01-25 17:49:53.632 CST [common.tools.configtxgen.encoder] NewChannelGroup -> WARN 006 Default policy emission is deprecated, please include policy specifications for the channel group in configtx.yaml
2021-01-25 17:49:53.632 CST [common.tools.configtxgen.encoder] NewApplicationOrgGroup -> WARN 007 Default policy emission is deprecated, please include policy specifications for the application org group Org1MSP in configtx.yaml
2021-01-25 17:49:53.632 CST [common.tools.configtxgen.encoder] NewApplicationOrgGroup -> WARN 008 Default policy emission is deprecated, please include policy specifications for the application org group Org4MSP in configtx.yaml
2021-01-25 17:49:53.632 CST [common.tools.configtxgen.encoder] NewChannelGroup -> WARN 009 Default policy emission is deprecated, please include policy specifications for the channel group in configtx.yaml
2021-01-25 17:49:53.633 CST [common.tools.configtxgen.encoder] NewApplicationOrgGroup -> WARN 00a Default policy emission is deprecated, please include policy specifications for the application org group Org1MSP in configtx.yaml
2021-01-25 17:49:53.654 CST [common.tools.configtxgen.encoder] NewApplicationOrgGroup -> WARN 00b Default policy emission is deprecated, please include policy specifications for the application org group Org4MSP in configtx.yaml
2021-01-25 17:49:53.654 CST [common.tools.configtxgen] doOutputChannelCreateTx -> INFO 00c Writing new channel tx
```

```BASH
2021-01-25 17:52:20.295 CST [common.tools.configtxgen] main -> INFO 001 Loading configuration
2021-01-25 17:52:20.384 CST [common.tools.configtxgen.localconfig] Load -> INFO 002 Loaded configuration: /home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig/configtx.yaml
2021-01-25 17:52:20.474 CST [common.tools.configtxgen.localconfig] completeInitialization -> INFO 003 orderer type: solo
2021-01-25 17:52:20.474 CST [common.tools.configtxgen.localconfig] LoadTopLevel -> INFO 004 Loaded configuration: /home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig/configtx.yaml
2021-01-25 17:52:20.474 CST [common.tools.configtxgen] doOutputAnchorPeersUpdate -> INFO 005 Generating anchor peer update
2021-01-25 17:52:20.474 CST [common.tools.configtxgen] doOutputAnchorPeersUpdate -> INFO 006 Writing anchor peer update
```

观察输出可以发现，这两个命令分别做了三件事：

* 读取配置文件
* 生成新的`channel.tx`或update
* 写入新的`channel.tx`或update

实际上这时还没有这个channel的创世块，这里只是生成了<u>提案文件</u>，用来给之后生成创世块做准备。所以这两个命令没有副作用。

执行完毕，自动生成两个文件`Org1Channel.tx`和`Org1MSPanchors.tx`

```bash
├── peer1
│   ├── Org1Channel.tx
│   ├── Org1MSPanchors.tx
│   └── production
│       ├── chaincodes
│       └── ledgersData
```

## 4.2 创建channel的创世区块

回顾通道配置文件中的设置，我们要在org1和org4之间进行创建通道(channel)，这会生成一个channel的创世块。而在Fabric中跟区块链相关的操作都需要正确的证书签名。

* 所以需要设置`CORE_PEER_LOCALMSPID`，用来**指明**我们将要进行`peer`命令操作的对象的身份，该值在`core.yaml`中，必须一致。
* `CORE_PEER_MSPCONFIGPATH`是证书路径，创建channel操作需要管理员`Admin`的证书，所以所赋的值为`Admin@org1.dy`的`msp`
* 最后进行创建通道的命令：`peer channel create`，同时会输出一个区块
  * `-t / --timeout duration'`：创建通道的最大持续时间（默认10s）
  * `-o / --orderer `：orderer节点的端口地址，域名在`cryptogen-config.yaml`中已写明，端口在`orderer.yaml`在。需要明确地址的原因是该通道创建操作需要得到排序节点orderer的确认和排序。
  * ` -c / --channelID`：这个需要和生成建立channel提案文件所写的一致（要求必须是小写）。
  * ` -f / --file`：指明<u>建立通道提案文件</u>的路径，也就是刚刚生成`Org1Channel.tx`的路径，其中包含了该通道的配置信息，会提交给orderer节点。
  * `--outputBlock`：指明该通道创始区块的生成路径，默认为`./<channelID>.block`，所以我们先**进入peer1文件夹**。

> **注意**：由于是单机部署，所以创建通道时，需要在另一个终端上启动排序节点`orderer start`

```bash
export FABRIC_CFG_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig
export FABRIC_PROJECT_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric

export CORE_PEER_LOCALMSPID=Org1MSP
export CORE_PEER_MSPCONFIGPATH=$FABRIC_CFG_PATH/crypto-config/peerOrganizations/org1.dy/users/Admin@org1.dy/msp
export CORE_PEER_ADDRESS=peer0.org1.dy:7061

cd $FABRIC_PROJECT_PATH/peer1

peer channel create -t 50s -o orderer.dy:7050 -c org1channel -f $FABRIC_PROJECT_PATH/peer1/Org1Channel.tx 

# 输出如下
2021-01-26 11:20:34.500 CST [channelCmd] InitCmdFactory -> INFO 001 Endorser and orderer connections initialized
2021-01-26 11:20:34.653 CST [cli.common] readBlock -> INFO 002 Received block: 0
```

查看运行中的`orderer`节点会显示类似如下的日志：

```shell
2021-01-26 11:17:59.013 CST [comm.grpc.server] 1 -> INFO 014 streaming call completed grpc.service=orderer.AtomicBroadcast grpc.method=Deliver grpc.peer_address=127.0.0.1:36208 error="rpc error: code = Canceled desc = context canceled" grpc.code=Canceled grpc.call_duration=6.952581ms
2021-01-26 11:20:34.536 CST [comm.grpc.server] 1 -> INFO 015 streaming call completed grpc.service=orderer.AtomicBroadcast grpc.method=Broadcast grpc.peer_address=127.0.0.1:36214 grpc.code=OK grpc.call_duration=35.020028ms
2021-01-26 11:20:34.539 CST [fsblkstorage] newBlockfileMgr -> INFO 016 Getting block information from block storage
2021-01-26 11:20:34.650 CST [orderer.commmon.multichannel] newChain -> INFO 017 Created and starting new chain org1channel
2021-01-26 11:20:34.676 CST [comm.grpc.server] 1 -> INFO 018 streaming call completed grpc.service=orderer.AtomicBroadcast grpc.method=Deliver grpc.peer_address=127.0.0.1:36212 grpc.code=OK grpc.call_duration=175.789332ms
```

项目结构如下：

```BASH
root@localhost fabric # tree -L 2
.
├── fabricconfig
│   ├── configtx.yaml
│   ├── core1.yaml
│   ├── core2.yaml
│   ├── core3.yaml
│   ├── core.yaml
│   ├── crypto-config
│   ├── cryptogen_config.yaml
│   └── orderer.yaml
├── orderer
│   ├── orderer.genesis.block
│   └── production
├── peer1
│   ├── org1channel.block
│   ├── Org1Channel.tx
│   ├── Org1MSPanchors.tx
│   └── production
├── peer2
│   └── production
├── peer3
│   └── production
└── peer4
    └── production
```

但是，此时的peer1还不会有输出。因为我们虽然新建了一个channel，但只是生成了这个channel的创世块，还没有将组织org1加入进去。

## 4.2 将org1加入新创建的channel

```bash
export FABRIC_PROJECT_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric

export CORE_PEER_LOCALMSPID=Org1MSP
export CORE_PEER_MSPCONFIGPATH=$FABRIC_CFG_PATH/crypto-config/peerOrganizations/org1.dy/users/Admin@org1.dy/msp
export CORE_PEER_ADDRESS=peer0.org1.dy:7061

peer channel join -b $FABRIC_PROJECT_PATH/peer1/org1channel.block
```

---

##### Q连接节点失败原因

如果重启虚拟机后执行上述命令，会出现如下报错：

```bash
root@localhost peer1 $ peer channel join -b $FABRIC_PROJECT_PATH/peer1/org1channel.block
Error: error getting endorser client for channel: endorser client failed to connect to peer0.org1.dy:7061: failed to create new connection: connection error: desc = "transport: error while dialing: dial tcp 127.0.0.1:7061: connect: connection refused"
```

原因是没有启动peer节点，由于是单机部署，所以少许麻烦，需要启动该节点才行，也就是修改对应peer的`core.yaml`配置文件名称，然后执行`peer node start`

---

若无报错，则输出如下所示：

```bash
root@localhost peer1 $ peer channel join -b $FABRIC_PROJECT_PATH/peer1/org1channel.block

2021-01-26 15:00:40.285 CST [channelCmd] InitCmdFactory -> INFO 001 Endorser and orderer connections initialized
2021-01-26 15:00:40.756 CST [channelCmd] executeJoin -> INFO 002 Successfully submitted proposal to join channel
```

另外，peer1运行终端可看到如下日志：

```bash
2021-01-27 11:21:13.068 CST [sccapi] deploySysCC -> INFO 02c system chaincode lscc/org1channel(github.com/hyperledger/fabric/core/scc/lscc) deployed
2021-01-27 11:21:13.068 CST [cscc] Init -> INFO 02d Init CSCC
2021-01-27 11:21:13.068 CST [sccapi] deploySysCC -> INFO 02e system chaincode cscc/org1channel(github.com/hyperledger/fabric/core/scc/cscc) deployed
2021-01-27 11:21:13.068 CST [qscc] Init -> INFO 02f Init QSCC
2021-01-27 11:21:13.068 CST [sccapi] deploySysCC -> INFO 030 system chaincode qscc/org1channel(github.com/hyperledger/fabric/core/scc/qscc) deployed
2021-01-27 11:21:13.068 CST [sccapi] deploySysCC -> INFO 031 system chaincode (+lifecycle,github.com/hyperledger/fabric/core/chaincode/lifecycle) disabled
2021-01-27 11:21:13.069 CST [endorser] callChaincode -> INFO 032 [][4ebd0fff] Exit chaincode: name:"cscc"  (526ms)
2021-01-27 11:21:13.069 CST [comm.grpc.server] 1 -> INFO 033 unary call completed grpc.service=protos.Endorser grpc.method=ProcessProposal grpc.peer_address=127.0.0.1:34100 grpc.code=OK grpc.call_duration=527.634489ms
2021-01-27 11:21:19.068 CST [gossip.election] beLeader -> INFO 034 5140d295d2ef78679b70838a3ffaf674474b5e8d29ca7c117dc17e10923c9b16 : Becoming a leader
2021-01-27 11:21:19.069 CST [gossip.service] func1 -> INFO 035 Elected as a leader, starting delivery service for channel org1channel
```

这是调用系统chaincode将peer加入区块，并推举该节点为这个channel的leader的过程。

我们可以用peer channel list来确认是否成功加入了channel

```bash
root@localhost peer1 # peer channel list
2021-01-27 11:23:51.459 CST [channelCmd] InitCmdFactory -> INFO 001 Endorser and orderer connections initialized
Channels peers has joined: 
org1channel
```

## 4.4 更新锚节点

```bash
export FABRIC_PROJECT_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric

peer channel update -o orderer.dy:7050 -c org1channel -f $FABRIC_PROJECT_PATH/peer1/Org1MSPanchorsInOrg1Channel.tx
```

> `-o` orderer的地址
> `-c` channel ID
> `-f` 指明先前生成的锚节点更新文件的位置

输出如下：

```BASH
2021-01-27 11:28:06.175 CST [channelCmd] InitCmdFactory -> INFO 001 Endorser and orderer connections initialized
2021-01-27 11:28:06.187 CST [channelCmd] update -> INFO 002 Successfully submitted channel update
```

peer1终端的日志如下：

```BASH
2021-01-27 11:28:06.265 CST [gossip.privdata] StoreBlock -> INFO 03b [org1channel] Received block [1] from buffer
2021-01-27 11:28:06.272 CST [gossip.gossip] JoinChan -> INFO 03c Joining gossip network of channel org1channel with 2 organizations
2021-01-27 11:28:06.272 CST [gossip.gossip] learnAnchorPeers -> INFO 03d Learning about the configured anchor peers of Org1MSP for channel org1channel: [{peer0.org1.dy 7061}]
2021-01-27 11:28:06.272 CST [gossip.gossip] learnAnchorPeers -> INFO 03e Anchor peer for channel org1channel with same endpoint, skipping connecting to myself
2021-01-27 11:28:06.272 CST [gossip.gossip] learnAnchorPeers -> INFO 03f No configured anchor peers of Org4MSP for channel org1channel to learn about
2021-01-27 11:28:06.274 CST [committer.txvalidator] Validate -> INFO 040 [org1channel] Validated block [1] in 8ms
2021-01-27 11:28:06.479 CST [kvledger] CommitWithPvtData -> INFO 041 [org1channel] Committed block [1] with 1 transaction(s) in 204ms (state_validation=0ms block_and_pvtdata_commit=137ms state_commit=33ms) commitHash=[47dc540c94ceb704a23875c11273e16bb0b8a87aed84de911f2133568115f254]
```

peer1通过这一个命令，知道了这个channel中各个org的anchor。org1的anchor peer就是它自己，而org4还没有anchor peer。

### 将org4加入新创建的channel

```BASH
export FABRIC_PROJECT_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric
export FABRIC_CFG_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig

export CORE_PEER_LOCALMSPID=Org4MSP
export CORE_PEER_MSPCONFIGPATH=$FABRIC_CFG_PATH/crypto-config/peerOrganizations/org4.dy/users/Admin@org4.dy/msp
export CORE_PEER_ADDRESS=peer0.org4.dy:7064

peer channel join -b $FABRIC_PROJECT_PATH/peer1/org1channel.block
```

这里和org1加入channel差不多。

需要注意的是，多机部署时，org4的机器里没有`peer1/org1channel.block`，建议在上一步结束后，将org1的`$FABRIC_PROJECT_PATH/peer/org1channel.block`复制到org4的`$FABRIC_PROJECT_PATH/peer/`。

成功输出如下：

```bash
root@localhost peer1 $ peer channel join -b $FABRIC_PROJECT_PATH/peer1/org1channel.block
2021-01-27 12:08:33.975 CST [channelCmd] InitCmdFactory -> INFO 001 Endorser and orderer connections initialized
2021-01-27 12:08:34.447 CST [channelCmd] executeJoin -> INFO 002 Successfully submitted proposal to join channel
```

peer4终端日志如下：

```BASH
2021-01-27 12:08:40.445 CST [gossip.election] beLeader -> INFO 034 5cfe2ec45ad9b113c3440e1292b5e1403fb4c8d04c8af7aa2daea7bcf5f52703 : Becoming a leader
2021-01-27 12:08:40.445 CST [gossip.service] func1 -> INFO 035 Elected as a leader, starting delivery service for channel org1channel
2021-01-27 12:08:40.446 CST [deliveryClient] StartDeliverForChannel -> INFO 036 This peer will retrieve blocks from ordering service and disseminate to other peers in the organization for channel org1channel
2021-01-27 12:08:40.450 CST [deliveryClient] RequestBlocks -> INFO 037 Starting deliver with block [1] for channel org1channel
2021-01-27 12:08:40.454 CST [gossip.privdata] StoreBlock -> INFO 038 [org1channel] Received block [1] from buffer
2021-01-27 12:08:40.460 CST [gossip.gossip] JoinChan -> INFO 039 Joining gossip network of channel org1channel with 2 organizations
2021-01-27 12:08:40.460 CST [gossip.gossip] learnAnchorPeers -> INFO 03a Learning about the configured anchor peers of Org1MSP for channel org1channel: [{peer0.org1.dy 7061}]
2021-01-27 12:08:40.460 CST [gossip.gossip] learnAnchorPeers -> INFO 03b No configured anchor peers of Org4MSP for channel org1channel to learn about
2021-01-27 12:08:40.463 CST [committer.txvalidator] Validate -> INFO 03c [org1channel] Validated block [1] in 8ms
2021-01-27 12:08:40.677 CST [kvledger] CommitWithPvtData -> INFO 03d [org1channel] Committed block [1] with 1 transaction(s) in 214ms (state_validation=0ms block_and_pvtdata_commit=147ms state_commit=33ms) commitHash=[47dc540c94ceb704a23875c11273e16bb0b8a87aed84de911f2133568115f254]
2021-01-27 12:08:44.323 CST [gossip.channel] reportMembershipChanges -> INFO 03e Membership view has changed. peers went online:  [[peer0.org1.dy:7061 ]] , current view:  [[peer0.org1.dy:7061 ]]
```

peer1终端日志显示如下：

```bash
2021-01-27 12:08:40.480 CST [comm.grpc.server] 1 -> INFO 044 unary call completed grpc.service=gossip.Gossip grpc.method=Ping grpc.request_deadline=2021-01-27T12:08:42.48+08:00 grpc.peer_address=127.0.0.1:34116 grpc.code=OK grpc.call_duration=90.425µs
2021-01-27 12:08:42.964 CST [gossip.channel] reportMembershipChanges -> INFO 045 Membership view has changed. peers went online:  [[peer0.org4.dy:7064 ]] , current view:  [[peer0.org4.dy:7064 ]]
```

可以注意到，虽然Membership view自动更新了，但依然没有org4的anchor peer的信息。虽然似乎不影响运行，但我们也可以为更新一下。步骤和上面类似

#### 更新锚节点

```bash
export FABRIC_PROJECT_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric
export FABRIC_CFG_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig


export CORE_PEER_LOCALMSPID=Org4MSP
export CORE_PEER_MSPCONFIGPATH=$FABRIC_CFG_PATH/crypto-config/peerOrganizations/org4.dy/users/Admin@org4.dy/msp
export CORE_PEER_ADDRESS=peer0.org4.dy:7064

configtxgen -profile Org1Channel -outputAnchorPeersUpdate $FABRIC_PROJECT_PATH/peer4/Org4MSPanchors.tx -channelID org1channel -asOrg Org4MSP  ## 创建锚节点

peer channel update -o orderer.dy:7050 -c org1channel -f $FABRIC_PROJECT_PATH/peer4/Org4MSPanchors.tx
```

需要注意的是，如果在多机部署时，org4在不同channel的锚节点更新配置文件应该不是同一个。
建议修改configtxgen的`-outputAnchorPeersUpdate`参数和`peer channel update`的-f参数，让不同channel的这个文件错开来。

> `-outputAnchorPeersUpdate` ：创建一个更新锚节点的配置更新（仅在默认通道创建时有效，并仅用于第一次更新

成功输出如下：

```BASH
root@localhost peer4 $ peer channel update -o orderer.dy:7050 -c org1channel -f $FABRIC_PROJECT_PATH/peer4/Org4MSPanchors.tx
2021-01-27 12:21:15.108 CST [channelCmd] InitCmdFactory -> INFO 001 Endorser and orderer connections initialized
2021-01-27 12:21:15.119 CST [channelCmd] update -> INFO 002 Successfully submitted channel update
```

另外，对于peer4和peer1，都有日志输出显示，以下为pee4输出：

```BASH
2021-01-27 12:21:15.192 CST [gossip.privdata] StoreBlock -> INFO 03f [org1channel] Received block [2] from buffer
2021-01-27 12:21:15.199 CST [gossip.gossip] JoinChan -> INFO 040 Joining gossip network of channel org1channel with 2 organizations
2021-01-27 12:21:15.199 CST [gossip.gossip] learnAnchorPeers -> INFO 041 Learning about the configured anchor peers of Org4MSP for channel org1channel: [{peer0.org4.dy 7064}]
2021-01-27 12:21:15.199 CST [gossip.gossip] learnAnchorPeers -> INFO 042 Anchor peer for channel org1channel with same endpoint, skipping connecting to myself
2021-01-27 12:21:15.199 CST [gossip.gossip] learnAnchorPeers -> INFO 043 Learning about the configured anchor peers of Org1MSP for channel org1channel: [{peer0.org1.dy 7061}]
2021-01-27 12:21:15.201 CST [committer.txvalidator] Validate -> INFO 044 [org1channel] Validated block [2] in 9ms
2021-01-27 12:21:15.204 CST [comm.grpc.server] 1 -> INFO 045 unary call completed grpc.service=gossip.Gossip grpc.method=Ping grpc.request_deadline=2021-01-27T12:21:17.204+08:00 grpc.peer_address=127.0.0.1:32978 grpc.code=OK grpc.call_duration=105.71µs
2021-01-27 12:21:15.209 CST [comm.grpc.server] 1 -> INFO 046 streaming call completed grpc.service=gossip.Gossip grpc.method=GossipStream grpc.request_deadline=2021-01-27T12:21:25.205+08:00 grpc.peer_address=127.0.0.1:32978 error="rpc error: code = Canceled desc = context canceled" grpc.code=Canceled grpc.call_duration=3.481408ms
2021-01-27 12:21:15.211 CST [comm.grpc.server] 1 -> INFO 047 unary call completed grpc.service=gossip.Gossip grpc.method=Ping grpc.request_deadline=2021-01-27T12:21:17.211+08:00 grpc.peer_address=127.0.0.1:32980 grpc.code=OK grpc.call_duration=142.353µs
2021-01-27 12:21:15.430 CST [kvledger] CommitWithPvtData -> INFO 048 [org1channel] Committed block [2] with 1 transaction(s) in 228ms (state_validation=0ms block_and_pvtdata_commit=144ms state_commit=41ms) commitHash=[5f88b61407b149a48413433f4670c46531e5c4a8febdc339a9536ff8716a559e]
```

peer1输出如下：

```BASH
2021-01-27 12:21:15.192 CST [gossip.privdata] StoreBlock -> INFO 046 [org1channel] Received block [2] from buffer
2021-01-27 12:21:15.199 CST [gossip.gossip] JoinChan -> INFO 047 Joining gossip network of channel org1channel with 2 organizations
2021-01-27 12:21:15.199 CST [gossip.gossip] learnAnchorPeers -> INFO 048 Learning about the configured anchor peers of Org4MSP for channel org1channel: [{peer0.org4.dy 7064}]
2021-01-27 12:21:15.199 CST [gossip.gossip] learnAnchorPeers -> INFO 049 Learning about the configured anchor peers of Org1MSP for channel org1channel: [{peer0.org1.dy 7061}]
2021-01-27 12:21:15.199 CST [gossip.gossip] learnAnchorPeers -> INFO 04a Anchor peer for channel org1channel with same endpoint, skipping connecting to myself
2021-01-27 12:21:15.202 CST [committer.txvalidator] Validate -> INFO 04b [org1channel] Validated block [2] in 9ms1 transaction(s) in 228ms (state_validation=0ms block_and_pvtdata_commit=144ms state_commit=41ms) commitHash=[5f88b61407b149a48413433f4670c46531e5c4a8febdc339a9536ff8716a559e]
```

可以看出，他们现在知道这个channel中org1和org4的锚节点是谁了。

## 为peer2和peer4，peer3和peer4建立channel

与peer1和peer4建立channel的步骤一样。需要把参数修改为对应peer的参数。

### Org2和Org4建立通道

```BASH
### 暂时规定环境变量
export FABRIC_CFG_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig
export FABRIC_PROJECT_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric

### 生成通道提案
configtxgen -profile Org2Channel -outputCreateChannelTx $FABRIC_CFG_PATH/../peer2/Org2Channel.tx -channelID org2channel

### 指明操作对象身份
export CORE_PEER_LOCALMSPID=Org2MSP
export CORE_PEER_MSPCONFIGPATH=$FABRIC_CFG_PATH/crypto-config/peerOrganizations/org2.dy/users/Admin@org2.dy/msp
export CORE_PEER_ADDRESS=peer0.org2.dy:7062


cd $FABRIC_PROJECT_PATH/peer2  # 下方命令默认将创始区块生成在当前路径下

### 创建通道的创始区块
peer channel create -t 50s -o orderer.dy:7050 -c org2channel -f $FABRIC_PROJECT_PATH/peer2/Org2Channel.tx 

### 将org2加入新创建的通道
peer channel join -b $FABRIC_PROJECT_PATH/peer2/org2channel.block
### 输出org2锚节点交易
configtxgen -profile Org2Channel -outputAnchorPeersUpdate $FABRIC_CFG_PATH/../peer2/Org2MSPanchors.tx -channelID org2channel -asOrg Org2MSP
### 更新org2的锚节点
peer channel update -o orderer.dy:7050 -c org2channel -f $FABRIC_PROJECT_PATH/peer2/Org2MSPanchors.tx

### 指明操作对象身份
export CORE_PEER_LOCALMSPID=Org4MSP
export CORE_PEER_MSPCONFIGPATH=$FABRIC_CFG_PATH/crypto-config/peerOrganizations/org4.dy/users/Admin@org4.dy/msp
export CORE_PEER_ADDRESS=peer0.org4.dy:7064

### 将org4加入新创建的通道
peer channel join -b $FABRIC_PROJECT_PATH/peer2/org2channel.block
### 输出org4锚节点交易
configtxgen -profile Org2Channel -outputAnchorPeersUpdate $FABRIC_PROJECT_PATH/peer4/Org4MSPanchorsInOrg2Channel.tx -channelID org2channel -asOrg Org4MSP
### 更新org4的锚节点
peer channel update -o orderer.dy:7050 -c org2channel -f $FABRIC_PROJECT_PATH/peer4/Org4MSPanchorsInOrg2Channel.tx
```



### Org3和Org4建立通道

```BASH
### 暂时规定环境变量
export FABRIC_CFG_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig
export FABRIC_PROJECT_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric

### 生成通道提案
configtxgen -profile Org3Channel -outputCreateChannelTx $FABRIC_CFG_PATH/../peer3/Org3Channel.tx -channelID org3channel

### 指明操作对象身份（Org3）
export CORE_PEER_LOCALMSPID=Org3MSP
export CORE_PEER_MSPCONFIGPATH=$FABRIC_CFG_PATH/crypto-config/peerOrganizations/org3.dy/users/Admin@org3.dy/msp
export CORE_PEER_ADDRESS=peer0.org3.dy:7063

cd $FABRIC_PROJECT_PATH/peer3  # 下方命令默认将创始区块生成在当前路径下

### 根据提案创建通道的创始区块
peer channel create -t 50s -o orderer.dy:7050 -c org3channel -f $FABRIC_PROJECT_PATH/peer3/Org3Channel.tx 

### 将org3加入新创建的通道
peer channel join -b $FABRIC_PROJECT_PATH/peer3/org3channel.block
#### 输出org3的锚节点交易
configtxgen -profile Org3Channel -outputAnchorPeersUpdate $FABRIC_CFG_PATH/../peer3/Org3MSPanchors.tx -channelID org3channel -asOrg Org3MSP
#### 更新org3的锚节点
peer channel update -o orderer.dy:7050 -c org3channel -f $FABRIC_PROJECT_PATH/peer3/Org3MSPanchors.tx

### 指明操作对象身份（Org4）
export CORE_PEER_LOCALMSPID=Org4MSP
export CORE_PEER_MSPCONFIGPATH=$FABRIC_CFG_PATH/crypto-config/peerOrganizations/org4.dy/users/Admin@org4.dy/msp
export CORE_PEER_ADDRESS=peer0.org4.dy:7064

### 将org4加入新创建的通道（org3channel）
peer channel join -b $FABRIC_PROJECT_PATH/peer3/org3channel.block
#### 生成org4的锚节点交易
configtxgen -profile Org3Channel -outputAnchorPeersUpdate $FABRIC_PROJECT_PATH/peer4/Org4MSPanchorsInOrg3Channel.tx -channelID org3channel -asOrg Org4MSP
#### 更新org4的锚节点
peer channel update -o orderer.dy:7050 -c org3channel -f $FABRIC_PROJECT_PATH/peer4/Org4MSPanchorsInOrg3Channel.tx
```





# 5. 部署智能合约

> **注意**：Fabric目前采用**Docker容器**作为链码执行环境，因此即使在本地运行，链码服务器也需要安装Docker环境。
>
> 所以一下操作是通过docker容器完成的，主要通过`docker-compose`根据部署多容器，详情请见下方[说明](#docker-compose之使用CLI)

## 在peer1和peer4的通道上建立链码

> 注意：链码应该放在`$GOPATH$/src`路径下。
>
> 笔者放在`/usr/local/gopath/src/dy`路径下

```BASH
root@localhost dy # tree $GOPATH/src/github.com/dy -L 3
/usr/local/go/src/github.com/dy
├── comp1
│   └── cc_comp1.go
├── comp2
│   └── cc_comp2.go
└── comp3
    └── cc_comp3.go
```

### 链码文件解析指路

`cc_comp*.go`代码+分析=>[详情](./项目文件分析/链码文件.md)



## 5.1 安装链码

### 为peer1安装链码

```BASH
### 暂时规定环境变量
export FABRIC_CFG_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig
export FABRIC_PROJECT_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric

export ORDERER_GENERAL_LOGLEVEL=debug
export CORE_PEER_LOCALMSPID=Org1MSP
export CORE_PEER_ADDRESS=peer0.org1.dy:7061
export CORE_PEER_MSPCONFIGPATH=$FABRIC_CFG_PATH/crypto-config/peerOrganizations/org1.dy/users/Admin@org1.dy/msp/

peer chaincode install -n cc_comp1_or_gov -v 1.0 -p dy/comp1/
```

> 解释：
>
> ORDERER_GENERAL_LOGLEVEL就是log level
>
> `peer chaincode install`指令相关参考：https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/commands/peerchaincode.html
>
> * -n参数是我们为这个链码在channel上起的名字，
> * -v是自己指定的版本号，
> * -p则是链码文件的路径，路径是在`$GOPATH`下

我们安装的链码是供应用层调用的，因此在命名上更偏向业务。用comp1代表`peer0.org1(peer1)`，gov代表`peer0.org4(peer4)`。

成功输出如下：

```BASH
root@localhost fabricconfig $ peer chaincode install -n cc_comp1_or_gov -v 1.0 -p github.com/dy/comp1/
2021-01-28 19:41:57.630 CST [chaincodeCmd] checkChaincodeCmdParams -> INFO 001 Using default escc
2021-01-28 19:41:57.631 CST [chaincodeCmd] checkChaincodeCmdParams -> INFO 002 Using default vscc
2021-01-28 19:42:02.140 CST [chaincodeCmd] install -> INFO 003 Installed remotely response:<status:200 payload:"OK" > 
```

同时，peer1终端会输出：

```BASH
2021-01-28 19:42:02.006 CST [endorser] callChaincode -> INFO 064 [][f2990aa7] Entry chaincode: name:"lscc" 
2021-01-28 19:42:02.128 CST [lscc] executeInstall -> INFO 065 Installed Chaincode [cc_comp1_or_gov] Version [1.0] to peer
2021-01-28 19:42:02.128 CST [endorser] callChaincode -> INFO 066 [][f2990aa7] Exit chaincode: name:"lscc"  (122ms)
2021-01-28 19:42:02.128 CST [comm.grpc.server] 1 -> INFO 067 unary call completed grpc.service=protos.Endorser grpc.method=ProcessProposal grpc.peer_address=127.0.0.1:37338 grpc.code=OK grpc.call_duration=152.964242ms
```

可以看到，安装成功了。另外可以注意到，这个操作不是transaction，没有新区块打包。

## 5.2 实例化链码

### 在peer1上实例化链码

> Fabric目前采用**Docker容器**作为链码执行环境，因此即使在本地运行，链码服务器也需要安装Docker环境

链码安装后需要实例化。

```bash
### 暂时规定环境变量
export FABRIC_CFG_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig
export FABRIC_PROJECT_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric

export ORDERER_GENERAL_LOGLEVEL=debug
export CORE_PEER_LOCALMSPID=Org1MSP
export CORE_PEER_ADDRESS=peer0.org1.dy:7061
export CORE_PEER_MSPCONFIGPATH=$FABRIC_CFG_PATH/crypto-config/peerOrganizations/org1.dy/users/Admin@org1.dy/msp/


peer chaincode instantiate -o orderer.dy:7050 -C org1channel -n cc_comp1_or_gov -v 1.0 -c '{"Args":["init"]}' -P "OR ('Org1MSP.member', 'Org4MSP.member')"


```

> 节点链码实例化指令参考：https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/commands/peerchaincode.html
>
> * -o是orderer的地址
> * -C是channel的ID
> * -n是chaincode的名字，要和刚刚写的一致
> * -v是chaincode的版本号，要和刚刚写的一致
> * -c是发给chaincode的消息，需要是json格式。chaincode会根据这个来执行对应的函数。
> * -P(大写)是Policy，先前解释过。
>   * Policy是类似于AND('A', 'B')或者OR('A','B')的字符串，它定义了某个操作需要遵循何种规则由哪些组织背书才能通过。
>   * 按照官方推荐的做法，需要在生成创世块时就定义好一部分Policy。但是，我们目前只需要chaincode层面的Policy，这个可以在后面建立chaincode的时候再设置。
>
> 所谓chaincode层面的Policy，举个例子。对于某chaincode，有Policy为AND('A', 'B')。则这个chaincode上的所有事务的提案都必须同时得到A和B的背书才能被承认。
>
> * 而对于同时得到A和B的背书，实现方式是：A和B上实例化同样的chaincode，外部服务器的同时给AB发同样的grpc请求调用chaincode。
> * 对于OR('A','B')，只需要随便给AB之一发请求调用chaincode就能通过。

那么运行这个peer chaincode instantiate来在peer1上实例化链码
成功的输出如下。

```BASH
root@localhost peer1 $ peer chaincode instantiate -o orderer.dy:7050 -C org1channel -n cc_comp1_or_gov -v 1.0 -c '{"Args":["init"]}' -P "OR ('Org1MSP.member', 'Org4MSP.member')"
2021-01-28 20:44:05.873 CST [chaincodeCmd] checkChaincodeCmdParams -> INFO 001 Using default escc
2021-01-28 20:44:05.873 CST [chaincodeCmd] checkChaincodeCmdParams -> INFO 002 Using default vscc
```



## 为org1channel里的peer4安装链码

```bash
### 暂时规定环境变量
export FABRIC_CFG_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig
export FABRIC_PROJECT_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric

export ORDERER_GENERAL_LOGLEVEL=debug
export CORE_PEER_LOCALMSPID=Org4MSP
export CORE_PEER_ADDRESS=peer0.org4.dy:7064
export CORE_PEER_MSPCONFIGPATH=$FABRIC_CFG_PATH/crypto-config/peerOrganizations/org4.dy/users/Admin@org4.dy/msp/


peer chaincode install -n cc_comp1_or_gov -v 1.0 -p dy/comp1/


```

可以看到，安装的是和peer1相同的链码。我们只不过把操作的peer改成了peer4

```BASH
root@localhost fabric $ peer chaincode install -n cc_comp1_or_gov -v 1.0 -p github.com/dy/comp1/
2021-01-28 20:49:02.015 CST [chaincodeCmd] checkChaincodeCmdParams -> INFO 001 Using default escc
2021-01-28 20:49:02.015 CST [chaincodeCmd] checkChaincodeCmdParams -> INFO 002 Using default vscc
2021-01-28 20:49:02.931 CST [chaincodeCmd] install -> INFO 003 Installed remotely response:<status:200 payload:"OK" > 
```

## 测试链码的调用

我们为org1channel上的peer1和peer4安装了相同的链码。
这个链码只在peer1上实例化了。
这个链码的Policy是"OR ('Org1MSP.member', 'Org4MSP.member')"，就是说只要Org1或Org4中的随便一个member调用就能通过。即，peer1或者peer4两者可以直接调用链码。

我们用peer4来调用。

```bash
### 暂时规定环境变量
export FABRIC_CFG_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric/fabricconfig
export FABRIC_PROJECT_PATH=/home/dongyangyu/ReviewCode/workSpace/fabric

export CORE_PEER_LOCALMSPID=Org4MSP
export CORE_PEER_ADDRESS=peer0.org4.dy:7064
export CORE_PEER_MSPCONFIGPATH=$FABRIC_CFG_PATH/crypto-config/peerOrganizations/org4.dy/users/Admin@org4.dy/msp/


peer chaincode invoke -o orderer.dy:7050 -C org1channel -n cc_comp1_or_gov -c '{"Args": ["invoke","putvalue" ,"vegetable001","{\"from\":\"Suzhou\",\"to\":\"Shanghai\"}"]}'
```

> 指令解释：
>
> -c参数是invoke，所以会调用chaincode的invoke函数；
>
> 在invoke函数中，又能拿到`putvalue`, `vegetable001`, `{\"from\":\"Suzhou\",\"to\":\"Shanghai\"}`三个参数，所以就新增了一个`vegetable001` key，设置其值为`{\"from\":\"Suzhou\",\"to\":\"Shanghai\"}`。这个操作是一个transaction，并在随后被打包进区块。

成功的话有如下输出

```BASH
 peer chaincode invoke -o orderer.dy:7050 -C org1channel -n cc_comp1_or_gov -c '{"Args": ["invoke","putvalue" ,"vegetable001","{\"from\":\"Suzhou\",\"to\":\"Shanghai\"}"]}'
2021-01-29 13:28:53.771 PDT [chaincodeCmd] chaincodeInvokeOrQuery -> INFO 001 Chaincode invoke successful. result: status:200 payload:"success put {\"from\":\"Suzhou\",\"to\":\"Shanghai\"}"
```

peer1和peer4也会有输出

```bash
# peer1
2021-01-30 02:53:21.107 UTC [gossip.privdata] StoreBlock -> INFO 0fd [org1channel] Received block [2] from buffer
2021-01-30 02:53:21.108 UTC [committer.txvalidator] Validate -> INFO 0fe [org1channel] Validated block [2] in 0ms
2021-01-30 02:53:21.282 UTC [kvledger] CommitWithPvtData -> INFO 0ff [org1channel] Committed block [2] with 1 transaction(s) in 173ms (state_validation=0ms block_and_pvtdata_commit=115ms state_commit=33ms) commitHash=[761af2399b316dade4facd3cd93d08ad701f217bd705cb78d6293a86b623c396]

```







# docker-compose之使用CLI

在fabric目录下新建`docker-compose.yaml`配置文件，用于部署多容器（[详解](./docker-compose详解.md)）

文件内容如下:

```YAML
version: "3.7"

services:
    orderer.dy:
        container_name: orderer
        command: orderer start
        hostname: orderer.dy
        image: hyperledger/fabric-orderer:1.4
        environment:
          - ORDERER_GENERAL_LOGLEVEL=debug
          - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0
          - ORDERER_GENERAL_LOCALMSPID=OrdererMSP
          - ORDERER_GENERAL_LOCALMSPDIR=/etc/hyperledger/fabric/crypto-config/ordererOrganizations/dy/orderers/orderer.dy/msp
          - ORDERER_GENERAL_GENESISMETHOD=file
          - ORDERER_GENERAL_GENESISFILE=/etc/hyperledger/fabric/orderer/orderer.genesis.block
          # enabled TLS
          - ORDERER_GENERAL_TLS_ENABLED=false
          - ORDERER_GENERAL_TLS_PRIVATEKEY=/etc/hyperledger/fabric/crypto-config/ordererOrganizations/dy/orderers/orderer.dy/tls/server.key
          - ORDERER_GENERAL_TLS_CERTIFICATE=/etc/hyperledger/fabric/crypto-config/ordererOrganizations/dy/orderers/orderer.dy/tls/server.crt
          - ORDERER_GENERAL_TLS_ROOTCAS=[/etc/hyperledger/fabric/crypto-config/ordererOrganizations/dy/orderers/orderer.dy/tls/ca.crt]
          - FABRIC_CFG_PATH=/etc/hyperledger/fabric

        networks: 
          - mynet
        ports:
          - 7050:7050
        working_dir: /opt/gopath/src/github.com/hyperledger/fabric
        volumes:
          - type: bind
            source: ./orderer/orderer.genesis.block
            target: /etc/hyperledger/fabric/orderer/orderer.genesis.block
            read_only: false
          - type: bind
            source: ./fabricconfig
            target: /etc/hyperledger/fabric
            read_only: false
          - type: bind
            source: ./fabricconfig/crypto-config
            target: /etc/hyperledger/fabric/crypto-config
            read_only: true

    peer0.org1.dy:
        command: peer node start --peer-chaincodedev=true
        working_dir: /etc/hyperledger/fabric
        hostname: peer0.org1.dy
        container_name: peer1
        image: hyperledger/fabric-peer:1.4.9
        depends_on:
          - orderer.dy
        networks: 
          - mynet
        environment:
          - GO111MODULE=off
          - GOPATH=/go
          - ORDERER_CA=/etc/hyperledger/crypto-config/ordererOrganizations/dy/msp/tlscacerts/tlsca.dy-cert.pem
          - CORE_VM_ENDPOINT=unix:///var/run/docker.sock
          - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=mynet
          - FABRIC_LOGGING_SPEC=INFO
          - CORE_PEER_ID=peer0.org1.dy
          - CORE_PEER_ADDRESS=peer0.org1.dy:7061
          - CORE_PEER_LOCALMSPID=Org1MSP
          - CORE_PEER_TLS_ENABLED=false
          - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/crypto-config/peerOrganizations/org1.dy/peers/peer0.org1.dy/tls/server.crt
          - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/crypto-config/peerOrganizations/org1.dy/peers/peer0.org1.dy/tls/server.key
          - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/crypto-config/peerOrganizations/org1.dy/peers/peer0.org1.dy/tls/ca.crt
          - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/crypto-config/peerOrganizations/org1.dy/users/Admin@org1.dy/msp
        ports:
          - 7061:7061
        volumes:
          - "/var/run/docker.sock:/var/run/docker.sock"
          - type: bind
            source: ./fabricconfig/core.yaml
            target: /etc/hyperledger/fabric/core.yaml
            read_only: true
            
          - type: bind
            source: ./fabricconfig/crypto-config
            target: /etc/hyperledger/crypto-config
            read_only: true

          # - type: bind
          #   source: ./channel
          #   target: /etc/hyperledger/channel
          #   read_only: false

          # - type: bind
          #   source: ./chaincode
          #   target: /go/src/chaincode
            
        healthcheck:
          test: ["CMD", "peer", "node", "status"]
          interval: 15s
          timeout: 5s
          retries: 3
          start_period: 4s


    peer0.org2.dy:
        command: peer node start --peer-chaincodedev=true
        working_dir: /etc/hyperledger/fabric
        hostname: peer0.org2.dy
        container_name: peer2
        image: hyperledger/fabric-peer:1.4.9
        depends_on:
          - orderer.dy
        networks: 
          - mynet
        ports:
          - 7062:7062
        environment:
          - GO111MODULE=off
          - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=mynet
          - GOPATH=/go
          - CORE_VM_ENDPOINT=unix:///var/run/docker.sock
          - ORDERER_CA=/etc/hyperledger/fabric/crypto-config/ordererOrganizations/dy/orderers/orderer.dy/msp/tlscacerts/tlsca.dy-cert.pem
          #- FABRIC_LOGGING_SPEC=DEBUG
          - FABRIC_LOGGING_SPEC=INFO
          - CORE_PEER_ID=peer0.org2.dy
          - CORE_PEER_ADDRESS=peer0.org2.dy:7062
          - CORE_PEER_LOCALMSPID=Org2MSP
          - CORE_PEER_TLS_ENABLED=false
          - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/crypto-config/peerOrganizations/org2.dy/peers/peer0.org2.dy/tls/server.crt
          - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/crypto-config/peerOrganizations/org2.dy/peers/peer0.org2.dy/tls/server.key
          - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/crypto-config/peerOrganizations/org2.dy/peers/peer0.org2.dy/tls/ca.crt
          - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/crypto-config/peerOrganizations/org2.dy/users/Admin@org2.dy/msp
        volumes:
          - "/var/run/docker.sock:/var/run/docker.sock"
          - type: bind
            source: ./fabricconfig/core2.yaml
            target: /etc/hyperledger/fabric/core.yaml
            read_only: true
            
          - type: bind
            source: ./fabricconfig/crypto-config
            target: /etc/hyperledger/fabric/crypto-config
            read_only: true
            
        healthcheck:
          test: ["CMD", "peer", "node", "status"]
          interval: 15s
          timeout: 5s
          retries: 3
          start_period: 4s

    peer0.org3.dy:
        command: peer node start --peer-chaincodedev=true
        working_dir: /etc/hyperledger/fabric
        hostname: peer0.org3.dy
        container_name: peer3
        image: hyperledger/fabric-peer:1.4.9
        depends_on:
          - orderer.dy
        networks: 
          - mynet
        ports:
          - 7063:7063
        environment:
          - GO111MODULE=off
          - GOPATH=/go
          - CORE_VM_ENDPOINT=unix:///var/run/docker.sock
          - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=mynet
          - ORDERER_CA=/etc/hyperledger/fabric/crypto-config/ordererOrganizations/dy/orderers/orderer.dy/msp/tlscacerts/tlsca.dy-cert.pem
          #- FABRIC_LOGGING_SPEC=DEBUG
          - FABRIC_LOGGING_SPEC=INFO
          - CORE_PEER_ID=peer0.org3.dy
          - CORE_PEER_ADDRESS=peer0.org3.dy:7063
          - CORE_PEER_LOCALMSPID=Org3MSP
          - CORE_PEER_TLS_ENABLED=false
          - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/crypto-config/peerOrganizations/org3.dy/peers/peer0.org3.dy/tls/server.crt
          - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/crypto-config/peerOrganizations/org3.dy/peers/peer0.org3.dy/tls/server.key
          - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/crypto-config/peerOrganizations/org3.dy/peers/peer0.org3.dy/tls/ca.crt
          - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/crypto-config/peerOrganizations/org3.dy/users/Admin@org3.dy/msp
        volumes:
          - "/var/run/docker.sock:/var/run/docker.sock"
          - type: bind
            source: ./fabricconfig/core3.yaml
            target: /etc/hyperledger/fabric/core.yaml
            read_only: true
            
          - type: bind
            source: ./fabricconfig/crypto-config
            target: /etc/hyperledger/fabric/crypto-config
            read_only: true
            
        healthcheck:
          test: ["CMD", "peer", "node", "status"]
          interval: 15s
          timeout: 5s
          retries: 3
          start_period: 4s

    peer0.org4.dy:
        command: peer node start --peer-chaincodedev=true
        working_dir: /etc/hyperledger/fabric
        hostname: peer0.org4.dy
        container_name: peer4
        image: hyperledger/fabric-peer:1.4.9
        depends_on:
          - orderer.dy
        networks: 
          - mynet
        ports:
          - 7064:7064
        environment:
          - GO111MODULE=off
          - GOPATH=/go
          - CORE_VM_ENDPOINT=unix:///var/run/docker.sock
          - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=mynet
          - ORDERER_CA=/etc/hyperledger/fabric/crypto-config/ordererOrganizations/dy/orderers/orderer.dy/msp/tlscacerts/tlsca.dy-cert.pem
          #- FABRIC_LOGGING_SPEC=DEBUG
          - FABRIC_LOGGING_SPEC=INFO
          - CORE_PEER_ID=peer0.org4.dy
          - CORE_PEER_ADDRESS=peer0.org4.dy:7064
          - CORE_PEER_LOCALMSPID=Org4MSP
          - CORE_PEER_TLS_ENABLED=false
          - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/crypto-config/peerOrganizations/org4.dy/peers/peer0.org4.dy/tls/server.crt
          - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/crypto-config/peerOrganizations/org4.dy/peers/peer0.org4.dy/tls/server.key
          - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/crypto-config/peerOrganizations/org4.dy/peers/peer0.org4.dy/tls/ca.crt
          - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/crypto-config/peerOrganizations/org4.dy/users/Admin@org4.dy/msp
        volumes:
          - "/var/run/docker.sock:/var/run/docker.sock"
          - type: bind
            source: ./fabricconfig/core4.yaml
            target: /etc/hyperledger/fabric/core.yaml
            read_only: true
            
          - type: bind
            source: ./fabricconfig/crypto-config
            target: /etc/hyperledger/fabric/crypto-config
            read_only: true
          
          # - type: bind
          #   source: ./channel
          #   target: /etc/hyperledger/channel
          #   read_only: false

          # - type: bind
          #   source: ./chaincode
          #   target: /go/src/chaincode
            
        healthcheck:
          test: ["CMD", "peer", "node", "status"]
          interval: 15s
          timeout: 5s
          retries: 3
          start_period: 4s

    cli:
      container_name: cli
      image: hyperledger/fabric-tools:1.4.9
      tty: true
      stdin_open: true
      networks: 
        - mynet
      environment:
        - GOPATH=/opt/gopath
        - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
        - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=mynet
        #- FABRIC_LOGGING_SPEC=DEBUG
        - FABRIC_LOGGING_SPEC=INFO
        - CORE_PEER_ID=cli
        - CORE_PEER_ADDRESS=peer0.org1.dy:7061
        - CORE_PEER_LOCALMSPID=Org1MSP
        - CORE_PEER_TLS_ENABLED=false
        - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto-config/peerOrganizations/org1.dy/peers/peer0.org1.dy/tls/server.crt
        - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto-config/peerOrganizations/org1.dy/peers/peer0.org1.dy/tls/server.key
        - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto-config/peerOrganizations/org1.dy/peers/peer0.org1.dy/tls/ca.crt
        - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto-config/peerOrganizations/org1.dy/users/Admin@org1.dy/msp
      working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
      command: /bin/sh
      volumes:
        - "/var/run/docker.sock:/var/run/docker.sock"
        - type: bind
          source: ./fabricconfig/crypto-config
          target: /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto-config
          read_only: true
        - type: bind
          source: ./orderer/orderer.genesis.block
          target: /opt/gopath/src/github.com/hyperledger/fabric/channel-artifacts/orderer.genesis.block
          read_only: false
        - type: bind
          source: ./peer1/Org1Channel.tx
          target: /opt/gopath/src/github.com/hyperledger/fabric/channel-artifacts/Org1Channel.tx
          read_only: false

        # chaincode
        - type: bind
          source: /usr/local/gopath/src/dy/comp1/cc_comp1.go
          target: /opt/gopath/src/github.com/hyperledger/fabric/chaincode/cc_comp.go
          read_only: false
          
      # volumes:
      #     - /var/run/:/host/var/run/
      #     - ./../chaincode/:/opt/gopath/src/github.com/chaincode
      #     - ./crypto-config:/etc/hyperledger/crypto-config/
      #     - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/
      #     - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts
      depends_on:
        - orderer.dy
        - peer0.org1.dy
        - peer0.org2.dy
        - peer0.org3.dy
        - peer0.org4.dy

networks:
  mynet:
    name: mynet
```

其中路径配置（**volumes**）非常重要，需要关注本机下的路径（source），以及容器中的路径（target）；以及对应的环境变量的设置（**environments**）。

## CLI命令

单机单节点[参考](https://www.cnblogs.com/llongst/p/9571321.html)

```BASH
# 启动配置文件中的所有容器（一个orderer，4个peer）
docker-compose -f docker-compose.yaml up -d

# 使用docker-compose部署成功后，进入cli容器
root@localhost fabric $ docker exec -it cli bash 

# 通过已生成的提案创建channel，当前路径生成通道的创始区块org1channel.block
root@e7231bf55cfc:/opt/gopath/src/github.com/hyperledger/fabric$ peer channel create -t 50s -o orderer.dy:7050 -c org1channel -f channel-artifacts/Org1Channel.tx

# 将peer1加入org1channel通道
root@e7231bf55cfc:/opt/gopath/src/github.com/hyperledger/fabric$ peer channel join -b org1channel.block 

# 为peer1安装链码（智能合约） 
## -p则是链码文件的路径，路径默认是在$GOPATH/src下,由于我们将链码放在/opt/gopath/src/github.com/hyperledger/fabric/chaincode/cc_comp.go路径下，所以其路径为github.com/hyperledger/fabric/chaincode
root@e7231bf55cfc:/opt/gopath/src/github.com/hyperledger/fabric$ peer chaincode install -n cc_comp1_or_gov -v 1.0 -p github.com/hyperledger/fabric/chaincode

# 在peer1上实例化链码
root@e7231bf55cfc:/opt/gopath/src/github.com/hyperledger/fabric$ peer chaincode instantiate -o orderer.dy:7050 -C org1channel -n cc_comp1_or_gov -v 1.0 -c '{"Args":["init"]}' -P "OR ('Org1MSP.member', 'Org4MSP.member')"

# 调用链码（新增交易）
root@e7231bf55cfc:/opt/gopath/src/github.com/hyperledger/fabric$ peer chaincode invoke -o orderer.dy:7050 -C org1channel -n cc_comp1_or_gov -c '{"Args": ["invoke","putvalue" ,"vegetable001","{\"from\":\"Suzhou\",\"to\":\"Shanghai\"}"]}'


# 调用链码（查询刚刚加入的交易）
root@e7231bf55cfc:/opt/gopath/src/github.com/hyperledger/fabric$ peer chaincode invoke -o orderer.dy:7050 -C org1channel -n cc_comp1_or_gov -c '{"Args": ["invoke","gethistory" ,"vegetable001",""]}'
```







# Q端口被占用解决方法

```bash
2021-01-29 09:02:41.899 CST [orderer.common.server] Start -> PANI 003 failed to initialize operations subsystem: listen tcp 0.0.0.0:8443: bind: address already in use
panic: failed to initialize operations subsystem: listen tcp 0.0.0.0:8443: bind: address already in use
```

如果停止某个节点运行后想要重启，却发现如上报错，这是因为没有关闭原进程，导致端口被占用。

**解决方法一**

```bash
$ netstat -nap | grep 8443 # 查看该端口的运行程序
tcp6       0      0 :::8443                 :::*                    LISTEN      3075/orderer
$ kill -9 3075            # 通过PID 杀死进程
[1]+  Killed                  orderer start
$ orderer start   # 重新启动，成功
```

netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。

netstat选项说明:

```
-a或--all：显示所有连线中的Socket； 
-n或--numeric：直接使用ip地址，而不通过域名服务器； 
-p或--programs：显示正在使用Socket的程序识别码和程序名称； 
```

kill最经常使用的结束进程的信号是：

| Signal Name | Single Value | Effect         |
| :---------- | :----------- | :------------- |
| SIGHUP      | 1            | 挂起           |
| SIGINT      | 2            | 键盘的中断信号 |
| SIGKILL     | 9            | 发出杀死信号   |
| SIGTERM     | 15           | 发出终止信号   |
| SIGSTOP     | 17, 19, 23   | 停止进程       |



**解决方法二**

```BASH
killall -9 [进程名]
# 如：
killall -9 orderer
```

`killall`命令用于杀死指定名字的进程（kill processes by name），相比上面的方法，省去查PID的过程





# 参考

https://www.cnblogs.com/studyzy/p/7451276.html